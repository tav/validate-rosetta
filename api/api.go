// DO NOT EDIT.
// Generated by running: go run cmd/genapi/genapi.go

// Copyright 2021 Coinbase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package api provides a client for Rosetta API servers.
package api

import (
	"bytes"
	"fmt"
)

// BlockEventType values.
const (
	BlockAdded   BlockEventType = "block_added"
	BlockRemoved BlockEventType = "block_removed"
)

// CoinAction values.
const (
	CoinCreated CoinAction = "coin_created"
	CoinSpent   CoinAction = "coin_spent"
)

// CurveType values.
const (
	Edwards25519 CurveType = "edwards25519"
	Secp256k1    CurveType = "secp256k1"
	Secp256r1    CurveType = "secp256r1"
	Tweedle      CurveType = "tweedle"
)

// Direction values.
const (
	Backward Direction = "backward"
	Forward  Direction = "forward"
)

// ExemptionType values.
const (
	Dynamic        ExemptionType = "dynamic"
	GreaterOrEqual ExemptionType = "greater_or_equal"
	LessOrEqual    ExemptionType = "less_or_equal"
)

// Operator values.
const (
	And Operator = "and"
	Or  Operator = "or"
)

// SignatureType values.
const (
	ECDSA           SignatureType = "ecdsa"
	ECDSARecovery   SignatureType = "ecdsa_recovery"
	Ed25519         SignatureType = "ed25519"
	Schnorr1        SignatureType = "schnorr_1"
	SchnorrPoseidon SignatureType = "schnorr_poseidon"
)

// AccountBalanceRequest type.
//
// An AccountBalanceRequest is utilized to make a balance request on the
// /account/balance endpoint. If the block_identifier is populated, a historical
// balance query should be performed.
type AccountBalanceRequest struct {
	AccountIdentifier  AccountIdentifier
	BlockIdentifier    PartialBlockIdentifier
	BlockIdentifierSet bool
	// In some cases, the caller may not want to retrieve all available balances
	// for an AccountIdentifier. If the currencies field is populated, only
	// balances for the specified currencies will be returned. If not populated,
	// all available balances will be returned.
	Currencies        []Currency
	CurrenciesSet     bool
	NetworkIdentifier NetworkIdentifier
}

// Equal returns whether two AccountBalanceRequest values are equal.
func (v AccountBalanceRequest) Equal(o AccountBalanceRequest) bool {
	return v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.BlockIdentifierSet == o.BlockIdentifierSet && v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.CurrenciesSet == o.CurrenciesSet && CurrencySliceEqual(v.Currencies, o.Currencies) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier)
}

// Reset resets AccountBalanceRequest so that it can be reused.
func (v *AccountBalanceRequest) Reset() {
	v.AccountIdentifier.Reset()
	v.BlockIdentifier.Reset()
	v.BlockIdentifierSet = false
	if len(v.Currencies) > 0 {
		v.Currencies = v.Currencies[:0]
	}
	v.CurrenciesSet = false
	v.NetworkIdentifier.Reset()
}

// AccountBalanceResponse type.
//
// An AccountBalanceResponse is returned on the /account/balance endpoint. If an
// account has a balance for each AccountIdentifier describing it (ex: an ERC-20
// token balance on a few smart contracts), an account balance request must be
// made with each AccountIdentifier.
//
// The `coins` field was removed and replaced by by `/account/coins` in
// `v1.4.7`.
type AccountBalanceResponse struct {
	// A single account may have a balance in multiple currencies.
	Balances        []Amount
	BlockIdentifier BlockIdentifier
	// Account-based blockchains that utilize a nonce or sequence number should
	// include that number in the metadata. This number could be unique to the
	// identifier or global across the account address.
	Metadata    MapObject
	MetadataSet bool
}

// Equal returns whether two AccountBalanceResponse values are equal.
func (v AccountBalanceResponse) Equal(o AccountBalanceResponse) bool {
	return AmountSliceEqual(v.Balances, o.Balances) &&
		v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata)
}

// Reset resets AccountBalanceResponse so that it can be reused.
func (v *AccountBalanceResponse) Reset() {
	if len(v.Balances) > 0 {
		v.Balances = v.Balances[:0]
	}
	v.BlockIdentifier.Reset()
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
}

// AccountCoinsRequest is utilized to make a request on the /account/coins
// endpoint.
type AccountCoinsRequest struct {
	AccountIdentifier AccountIdentifier
	// In some cases, the caller may not want to retrieve coins for all
	// currencies for an AccountIdentifier. If the currencies field is
	// populated, only coins for the specified currencies will be returned. If
	// not populated, all unspent coins will be returned.
	Currencies    []Currency
	CurrenciesSet bool
	// Include state from the mempool when looking up an account's unspent
	// coins. Note, using this functionality breaks any guarantee of
	// idempotency.
	IncludeMempool    bool
	NetworkIdentifier NetworkIdentifier
}

// Equal returns whether two AccountCoinsRequest values are equal.
func (v AccountCoinsRequest) Equal(o AccountCoinsRequest) bool {
	return v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.CurrenciesSet == o.CurrenciesSet && CurrencySliceEqual(v.Currencies, o.Currencies) &&
		v.IncludeMempool == o.IncludeMempool &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier)
}

// Reset resets AccountCoinsRequest so that it can be reused.
func (v *AccountCoinsRequest) Reset() {
	v.AccountIdentifier.Reset()
	if len(v.Currencies) > 0 {
		v.Currencies = v.Currencies[:0]
	}
	v.CurrenciesSet = false
	v.IncludeMempool = false
	v.NetworkIdentifier.Reset()
}

// AccountCoinsResponse is returned on the /account/coins endpoint and includes
// all unspent Coins owned by an AccountIdentifier.
type AccountCoinsResponse struct {
	BlockIdentifier BlockIdentifier
	// If a blockchain is UTXO-based, all unspent Coins owned by an
	// account_identifier should be returned alongside the balance. It is highly
	// recommended to populate this field so that users of the Rosetta API
	// implementation don't need to maintain their own indexer to track their
	// UTXOs.
	Coins []Coin
	// Account-based blockchains that utilize a nonce or sequence number should
	// include that number in the metadata. This number could be unique to the
	// identifier or global across the account address.
	Metadata    MapObject
	MetadataSet bool
}

// Equal returns whether two AccountCoinsResponse values are equal.
func (v AccountCoinsResponse) Equal(o AccountCoinsResponse) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		CoinSliceEqual(v.Coins, o.Coins) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata)
}

// Reset resets AccountCoinsResponse so that it can be reused.
func (v *AccountCoinsResponse) Reset() {
	v.BlockIdentifier.Reset()
	if len(v.Coins) > 0 {
		v.Coins = v.Coins[:0]
	}
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
}

// AccountIdentifier type.
//
// The account_identifier uniquely identifies an account within a network. All
// fields in the account_identifier are utilized to determine this uniqueness
// (including the metadata field, if populated).
type AccountIdentifier struct {
	// The address may be a cryptographic public key (or some encoding of it) or
	// a provided username.
	Address string
	// Blockchains that utilize a username model (where the address is not a
	// derivative of a cryptographic public key) should specify the public
	// key(s) owned by the address in metadata.
	Metadata      MapObject
	MetadataSet   bool
	SubAccount    SubAccountIdentifier
	SubAccountSet bool
}

// Equal returns whether two AccountIdentifier values are equal.
func (v AccountIdentifier) Equal(o AccountIdentifier) bool {
	return v.Address == o.Address &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.SubAccountSet == o.SubAccountSet && v.SubAccount.Equal(o.SubAccount)
}

// Reset resets AccountIdentifier so that it can be reused.
func (v *AccountIdentifier) Reset() {
	v.Address = ""
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.SubAccount.Reset()
	v.SubAccountSet = false
}

// Allow specifies supported Operation status, Operation types, and all possible
// error statuses. This Allow object is used by clients to validate the
// correctness of a Rosetta Server implementation. It is expected that these
// clients will error if they receive some response that contains any of the
// above information that is not specified here.
type Allow struct {
	// BalanceExemptions is an array of BalanceExemption indicating which
	// account balances could change without a corresponding Operation.
	//
	// BalanceExemptions should be used sparingly as they may introduce
	// significant complexity for integrators that attempt to reconcile all
	// account balance changes.
	//
	// If your implementation relies on any BalanceExemptions, you MUST
	// implement historical balance lookup (the ability to query an account
	// balance at any BlockIdentifier).
	BalanceExemptions []BalanceExemption
	// All methods that are supported by the /call endpoint. Communicating which
	// parameters should be provided to /call is the responsibility of the
	// implementer (this is en lieu of defining an entire type system and
	// requiring the implementer to define that in Allow).
	CallMethods []string
	// All Errors that this implementation could return. Any error that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	Errors []Error
	// Any Rosetta implementation that supports querying the balance of an
	// account at any height in the past should set this to true.
	HistoricalBalanceLookup bool
	// Any Rosetta implementation that can update an AccountIdentifier's unspent
	// coins based on the contents of the mempool should populate this field as
	// true. If false, requests to `/account/coins` that set `include_mempool`
	// as true will be automatically rejected.
	MempoolCoins bool
	// All Operation.Status this implementation supports. Any status that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	OperationStatuses []OperationStatus
	// All Operation.Type this implementation supports. Any type that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	OperationTypes []string
	// If populated, `timestamp_start_index` indicates the first block index
	// where block timestamps are considered valid (i.e. all blocks less than
	// `timestamp_start_index` could have invalid timestamps). This is useful
	// when the genesis block (or blocks) of a network have timestamp 0.
	//
	// If not populated, block timestamps are assumed to be valid for all
	// available blocks.
	TimestampStartIndex    int64
	TimestampStartIndexSet bool
}

// Equal returns whether two Allow values are equal.
func (v Allow) Equal(o Allow) bool {
	return BalanceExemptionSliceEqual(v.BalanceExemptions, o.BalanceExemptions) &&
		StringSliceEqual(v.CallMethods, o.CallMethods) &&
		ErrorSliceEqual(v.Errors, o.Errors) &&
		v.HistoricalBalanceLookup == o.HistoricalBalanceLookup &&
		v.MempoolCoins == o.MempoolCoins &&
		OperationStatusSliceEqual(v.OperationStatuses, o.OperationStatuses) &&
		StringSliceEqual(v.OperationTypes, o.OperationTypes) &&
		v.TimestampStartIndexSet == o.TimestampStartIndexSet && v.TimestampStartIndex == o.TimestampStartIndex
}

// Reset resets Allow so that it can be reused.
func (v *Allow) Reset() {
	if len(v.BalanceExemptions) > 0 {
		v.BalanceExemptions = v.BalanceExemptions[:0]
	}
	if len(v.CallMethods) > 0 {
		v.CallMethods = v.CallMethods[:0]
	}
	if len(v.Errors) > 0 {
		v.Errors = v.Errors[:0]
	}
	v.HistoricalBalanceLookup = false
	v.MempoolCoins = false
	if len(v.OperationStatuses) > 0 {
		v.OperationStatuses = v.OperationStatuses[:0]
	}
	if len(v.OperationTypes) > 0 {
		v.OperationTypes = v.OperationTypes[:0]
	}
	v.TimestampStartIndex = 0
	v.TimestampStartIndexSet = false
}

// Amount is some Value of a Currency. It is considered invalid to specify a
// Value without a Currency.
type Amount struct {
	Currency    Currency
	Metadata    MapObject
	MetadataSet bool
	// Value of the transaction in atomic units represented as an
	// arbitrary-sized signed integer.
	//
	// For example, 1 BTC would be represented by a value of 100000000.
	Value string
}

// Equal returns whether two Amount values are equal.
func (v Amount) Equal(o Amount) bool {
	return v.Currency.Equal(o.Currency) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.Value == o.Value
}

// Reset resets Amount so that it can be reused.
func (v *Amount) Reset() {
	v.Currency.Reset()
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.Value = ""
}

// BalanceExemption indicates that the balance for an exempt account could
// change without a corresponding Operation. This typically occurs with staking
// rewards, vesting balances, and Currencies with a dynamic supply.
//
// Currently, it is possible to exempt an account from strict reconciliation by
// SubAccountIdentifier.Address or by Currency. This means that any account with
// SubAccountIdentifier.Address would be exempt or any balance of a particular
// Currency would be exempt, respectively.
//
// BalanceExemptions should be used sparingly as they may introduce significant
// complexity for integrators that attempt to reconcile all account balance
// changes.
//
// If your implementation relies on any BalanceExemptions, you MUST implement
// historical balance lookup (the ability to query an account balance at any
// BlockIdentifier).
type BalanceExemption struct {
	Currency         Currency
	CurrencySet      bool
	ExemptionType    ExemptionType
	ExemptionTypeSet bool
	// SubAccountAddress is the SubAccountIdentifier.Address that the
	// BalanceExemption applies to (regardless of the value of
	// SubAccountIdentifier.Metadata).
	SubAccountAddress    string
	SubAccountAddressSet bool
}

// Equal returns whether two BalanceExemption values are equal.
func (v BalanceExemption) Equal(o BalanceExemption) bool {
	return v.CurrencySet == o.CurrencySet && v.Currency.Equal(o.Currency) &&
		v.ExemptionTypeSet == o.ExemptionTypeSet && v.ExemptionType == o.ExemptionType &&
		v.SubAccountAddressSet == o.SubAccountAddressSet && v.SubAccountAddress == o.SubAccountAddress
}

// Reset resets BalanceExemption so that it can be reused.
func (v *BalanceExemption) Reset() {
	v.Currency.Reset()
	v.CurrencySet = false
	v.ExemptionType = ""
	v.ExemptionTypeSet = false
	v.SubAccountAddress = ""
	v.SubAccountAddressSet = false
}

// Block type.
//
// Blocks contain an array of Transactions that occurred at a particular
// BlockIdentifier.
//
// A hard requirement for blocks returned by Rosetta implementations is that
// they MUST be _inalterable_: once a client has requested and received a block
// identified by a specific BlockIndentifier, all future calls for that same
// BlockIdentifier must return the same block contents.
type Block struct {
	BlockIdentifier       BlockIdentifier
	Metadata              MapObject
	MetadataSet           bool
	ParentBlockIdentifier BlockIdentifier
	Timestamp             Timestamp
	Transactions          []Transaction
}

// Equal returns whether two Block values are equal.
func (v Block) Equal(o Block) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.ParentBlockIdentifier.Equal(o.ParentBlockIdentifier) &&
		v.Timestamp == o.Timestamp &&
		TransactionSliceEqual(v.Transactions, o.Transactions)
}

// Reset resets Block so that it can be reused.
func (v *Block) Reset() {
	v.BlockIdentifier.Reset()
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.ParentBlockIdentifier.Reset()
	v.Timestamp = 0
	if len(v.Transactions) > 0 {
		v.Transactions = v.Transactions[:0]
	}
}

// BlockEvent represents the addition or removal of a BlockIdentifier from
// storage. Streaming BlockEvents allows lightweight clients to update their own
// state without needing to implement their own syncing logic.
type BlockEvent struct {
	BlockIdentifier BlockIdentifier
	// sequence is the unique identifier of a BlockEvent within the context of a
	// NetworkIdentifier.
	Sequence int64
	Type     BlockEventType
}

// Equal returns whether two BlockEvent values are equal.
func (v BlockEvent) Equal(o BlockEvent) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.Sequence == o.Sequence &&
		v.Type == o.Type
}

// Reset resets BlockEvent so that it can be reused.
func (v *BlockEvent) Reset() {
	v.BlockIdentifier.Reset()
	v.Sequence = 0
	v.Type = ""
}

// BlockEventType determines if a BlockEvent represents the addition or removal
// of a block.
type BlockEventType string

// Validate the BlockEventType value.
func (v BlockEventType) Validate() error {
	if !(v == "block_added" || v == "block_removed") {
		return fmt.Errorf("api: invalid BlockEventType value: %q", v)
	}
	return nil
}

// BlockIdentifier type.
//
// The block_identifier uniquely identifies a block in a particular network.
type BlockIdentifier struct {
	Hash string
	// This is also known as the block height.
	Index int64
}

// Equal returns whether two BlockIdentifier values are equal.
func (v BlockIdentifier) Equal(o BlockIdentifier) bool {
	return v.Hash == o.Hash &&
		v.Index == o.Index
}

// Reset resets BlockIdentifier so that it can be reused.
func (v *BlockIdentifier) Reset() {
	v.Hash = ""
	v.Index = 0
}

// BlockRequest type.
//
// A BlockRequest is utilized to make a block request on the /block endpoint.
type BlockRequest struct {
	BlockIdentifier   PartialBlockIdentifier
	NetworkIdentifier NetworkIdentifier
}

// Equal returns whether two BlockRequest values are equal.
func (v BlockRequest) Equal(o BlockRequest) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier)
}

// Reset resets BlockRequest so that it can be reused.
func (v *BlockRequest) Reset() {
	v.BlockIdentifier.Reset()
	v.NetworkIdentifier.Reset()
}

// BlockResponse type.
//
// A BlockResponse includes a fully-populated block or a partially-populated
// block with a list of other transactions to fetch (other_transactions).
//
// As a result of the consensus algorithm of some blockchains, blocks can be
// omitted (i.e. certain block indices can be skipped). If a query for one of
// these omitted indices is made, the response should not include a `Block`
// object.
//
// It is VERY important to note that blocks MUST still form a canonical,
// connected chain of blocks where each block has a unique index. In other
// words, the `PartialBlockIdentifier` of a block after an omitted block should
// reference the last non-omitted block.
type BlockResponse struct {
	Block    Block
	BlockSet bool
	// Some blockchains may require additional transactions to be fetched that
	// weren't returned in the block response (ex: block only returns
	// transaction hashes). For blockchains with a lot of transactions in each
	// block, this can be very useful as consumers can concurrently fetch all
	// transactions returned.
	OtherTransactions    []TransactionIdentifier
	OtherTransactionsSet bool
}

// Equal returns whether two BlockResponse values are equal.
func (v BlockResponse) Equal(o BlockResponse) bool {
	return v.BlockSet == o.BlockSet && v.Block.Equal(o.Block) &&
		v.OtherTransactionsSet == o.OtherTransactionsSet && TransactionIdentifierSliceEqual(v.OtherTransactions, o.OtherTransactions)
}

// Reset resets BlockResponse so that it can be reused.
func (v *BlockResponse) Reset() {
	v.Block.Reset()
	v.BlockSet = false
	if len(v.OtherTransactions) > 0 {
		v.OtherTransactions = v.OtherTransactions[:0]
	}
	v.OtherTransactionsSet = false
}

// BlockTransaction contains a populated Transaction and the BlockIdentifier
// that contains it.
type BlockTransaction struct {
	BlockIdentifier BlockIdentifier
	Transaction     Transaction
}

// Equal returns whether two BlockTransaction values are equal.
func (v BlockTransaction) Equal(o BlockTransaction) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.Transaction.Equal(o.Transaction)
}

// Reset resets BlockTransaction so that it can be reused.
func (v *BlockTransaction) Reset() {
	v.BlockIdentifier.Reset()
	v.Transaction.Reset()
}

// BlockTransactionRequest type.
//
// A BlockTransactionRequest is used to fetch a Transaction included in a block
// that is not returned in a BlockResponse.
type BlockTransactionRequest struct {
	BlockIdentifier       BlockIdentifier
	NetworkIdentifier     NetworkIdentifier
	TransactionIdentifier TransactionIdentifier
}

// Equal returns whether two BlockTransactionRequest values are equal.
func (v BlockTransactionRequest) Equal(o BlockTransactionRequest) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets BlockTransactionRequest so that it can be reused.
func (v *BlockTransactionRequest) Reset() {
	v.BlockIdentifier.Reset()
	v.NetworkIdentifier.Reset()
	v.TransactionIdentifier.Reset()
}

// BlockTransactionResponse type.
//
// A BlockTransactionResponse contains information about a block transaction.
type BlockTransactionResponse struct {
	Transaction Transaction
}

// Equal returns whether two BlockTransactionResponse values are equal.
func (v BlockTransactionResponse) Equal(o BlockTransactionResponse) bool {
	return v.Transaction.Equal(o.Transaction)
}

// Reset resets BlockTransactionResponse so that it can be reused.
func (v *BlockTransactionResponse) Reset() {
	v.Transaction.Reset()
}

// CallRequest is the input to the `/call` endpoint.
type CallRequest struct {
	// Method is some network-specific procedure call. This method could map to
	// a network-specific RPC endpoint, a method in an SDK generated from a
	// smart contract, or some hybrid of the two.
	//
	// The implementation must define all available methods in the Allow object.
	// However, it is up to the caller to determine which parameters to provide
	// when invoking `/call`.
	Method            string
	NetworkIdentifier NetworkIdentifier
	// Parameters is some network-specific argument for a method. It is up to
	// the caller to determine which parameters to provide when invoking
	// `/call`.
	Parameters MapObject
}

// Equal returns whether two CallRequest values are equal.
func (v CallRequest) Equal(o CallRequest) bool {
	return v.Method == o.Method &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		MapObjectEqual(v.Parameters, o.Parameters)
}

// Reset resets CallRequest so that it can be reused.
func (v *CallRequest) Reset() {
	v.Method = ""
	v.NetworkIdentifier.Reset()
	if len(v.Parameters) > 0 {
		v.Parameters = v.Parameters[:0]
	}
}

// CallResponse contains the result of a `/call` invocation.
type CallResponse struct {
	// Idempotent indicates that if `/call` is invoked with the same CallRequest
	// again, at any point in time, it will return the same CallResponse.
	//
	// Integrators may cache the CallResponse if this is set to true to avoid
	// making unnecessary calls to the Rosetta implementation. For this reason,
	// implementers should be very conservative about returning true here or
	// they could cause issues for the caller.
	Idempotent bool
	// Result contains the result of the `/call` invocation. This result will
	// not be inspected or interpreted by Rosetta tooling and is left to the
	// caller to decode.
	Result MapObject
}

// Equal returns whether two CallResponse values are equal.
func (v CallResponse) Equal(o CallResponse) bool {
	return v.Idempotent == o.Idempotent &&
		MapObjectEqual(v.Result, o.Result)
}

// Reset resets CallResponse so that it can be reused.
func (v *CallResponse) Reset() {
	v.Idempotent = false
	if len(v.Result) > 0 {
		v.Result = v.Result[:0]
	}
}

// Coin contains its unique identifier and the amount it represents.
type Coin struct {
	Amount         Amount
	CoinIdentifier CoinIdentifier
}

// Equal returns whether two Coin values are equal.
func (v Coin) Equal(o Coin) bool {
	return v.Amount.Equal(o.Amount) &&
		v.CoinIdentifier.Equal(o.CoinIdentifier)
}

// Reset resets Coin so that it can be reused.
func (v *Coin) Reset() {
	v.Amount.Reset()
	v.CoinIdentifier.Reset()
}

// CoinAction type.
//
// CoinActions are different state changes that a Coin can undergo. When a Coin
// is created, it is coin_created. When a Coin is spent, it is coin_spent. It is
// assumed that a single Coin cannot be created or spent more than once.
type CoinAction string

// Validate the CoinAction value.
func (v CoinAction) Validate() error {
	if !(v == "coin_created" || v == "coin_spent") {
		return fmt.Errorf("api: invalid CoinAction value: %q", v)
	}
	return nil
}

// CoinChange is used to represent a change in state of a some coin identified
// by a coin_identifier. This object is part of the Operation model and must be
// populated for UTXO-based blockchains.
//
// Coincidentally, this abstraction of UTXOs allows for supporting both
// account-based transfers and UTXO-based transfers on the same blockchain (when
// a transfer is account-based, don't populate this model).
type CoinChange struct {
	CoinAction     CoinAction
	CoinIdentifier CoinIdentifier
}

// Equal returns whether two CoinChange values are equal.
func (v CoinChange) Equal(o CoinChange) bool {
	return v.CoinAction == o.CoinAction &&
		v.CoinIdentifier.Equal(o.CoinIdentifier)
}

// Reset resets CoinChange so that it can be reused.
func (v *CoinChange) Reset() {
	v.CoinAction = ""
	v.CoinIdentifier.Reset()
}

// CoinIdentifier uniquely identifies a Coin.
type CoinIdentifier struct {
	// Identifier should be populated with a globally unique identifier of a
	// Coin. In Bitcoin, this identifier would be transaction_hash:index.
	Identifier string
}

// Equal returns whether two CoinIdentifier values are equal.
func (v CoinIdentifier) Equal(o CoinIdentifier) bool {
	return v.Identifier == o.Identifier
}

// Reset resets CoinIdentifier so that it can be reused.
func (v *CoinIdentifier) Reset() {
	v.Identifier = ""
}

// ConstructionCombineRequest is the input to the `/construction/combine`
// endpoint. It contains the unsigned transaction blob returned by
// `/construction/payloads` and all required signatures to create a network
// transaction.
type ConstructionCombineRequest struct {
	NetworkIdentifier   NetworkIdentifier
	Signatures          []Signature
	UnsignedTransaction string
}

// Equal returns whether two ConstructionCombineRequest values are equal.
func (v ConstructionCombineRequest) Equal(o ConstructionCombineRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		SignatureSliceEqual(v.Signatures, o.Signatures) &&
		v.UnsignedTransaction == o.UnsignedTransaction
}

// Reset resets ConstructionCombineRequest so that it can be reused.
func (v *ConstructionCombineRequest) Reset() {
	v.NetworkIdentifier.Reset()
	if len(v.Signatures) > 0 {
		v.Signatures = v.Signatures[:0]
	}
	v.UnsignedTransaction = ""
}

// ConstructionCombineResponse is returned by `/construction/combine`. The
// network payload will be sent directly to the `construction/submit` endpoint.
type ConstructionCombineResponse struct {
	SignedTransaction string
}

// Equal returns whether two ConstructionCombineResponse values are equal.
func (v ConstructionCombineResponse) Equal(o ConstructionCombineResponse) bool {
	return v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionCombineResponse so that it can be reused.
func (v *ConstructionCombineResponse) Reset() {
	v.SignedTransaction = ""
}

// ConstructionDeriveRequest is passed to the `/construction/derive` endpoint.
// Network is provided in the request because some blockchains have different
// address formats for different networks. Metadata is provided in the request
// because some blockchains allow for multiple address types (i.e. different
// address for validators vs normal accounts).
type ConstructionDeriveRequest struct {
	Metadata          MapObject
	MetadataSet       bool
	NetworkIdentifier NetworkIdentifier
	PublicKey         PublicKey
}

// Equal returns whether two ConstructionDeriveRequest values are equal.
func (v ConstructionDeriveRequest) Equal(o ConstructionDeriveRequest) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.PublicKey.Equal(o.PublicKey)
}

// Reset resets ConstructionDeriveRequest so that it can be reused.
func (v *ConstructionDeriveRequest) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.NetworkIdentifier.Reset()
	v.PublicKey.Reset()
}

// ConstructionDeriveResponse is returned by the `/construction/derive`
// endpoint.
type ConstructionDeriveResponse struct {
	AccountIdentifier    AccountIdentifier
	AccountIdentifierSet bool
	// [DEPRECATED by `account_identifier` in `v1.4.4`] Address in
	// network-specific format.
	Address     string
	AddressSet  bool
	Metadata    MapObject
	MetadataSet bool
}

// Equal returns whether two ConstructionDeriveResponse values are equal.
func (v ConstructionDeriveResponse) Equal(o ConstructionDeriveResponse) bool {
	return v.AccountIdentifierSet == o.AccountIdentifierSet && v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.AddressSet == o.AddressSet && v.Address == o.Address &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata)
}

// Reset resets ConstructionDeriveResponse so that it can be reused.
func (v *ConstructionDeriveResponse) Reset() {
	v.AccountIdentifier.Reset()
	v.AccountIdentifierSet = false
	v.Address = ""
	v.AddressSet = false
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
}

// ConstructionHashRequest is the input to the `/construction/hash` endpoint.
type ConstructionHashRequest struct {
	NetworkIdentifier NetworkIdentifier
	SignedTransaction string
}

// Equal returns whether two ConstructionHashRequest values are equal.
func (v ConstructionHashRequest) Equal(o ConstructionHashRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionHashRequest so that it can be reused.
func (v *ConstructionHashRequest) Reset() {
	v.NetworkIdentifier.Reset()
	v.SignedTransaction = ""
}

// ConstructionMetadataRequest type.
//
// A ConstructionMetadataRequest is utilized to get information required to
// construct a transaction.
//
// The Options object used to specify which metadata to return is left purposely
// unstructured to allow flexibility for implementers. Options is not required
// in the case that there is network-wide metadata of interest.
//
// Optionally, the request can also include an array of PublicKeys associated
// with the AccountIdentifiers returned in ConstructionPreprocessResponse.
type ConstructionMetadataRequest struct {
	NetworkIdentifier NetworkIdentifier
	// Some blockchains require different metadata for different types of
	// transaction construction (ex: delegation versus a transfer). Instead of
	// requiring a blockchain node to return all possible types of metadata for
	// construction (which may require multiple node fetches), the client can
	// populate an options object to limit the metadata returned to only the
	// subset required.
	Options       MapObject
	OptionsSet    bool
	PublicKeys    []PublicKey
	PublicKeysSet bool
}

// Equal returns whether two ConstructionMetadataRequest values are equal.
func (v ConstructionMetadataRequest) Equal(o ConstructionMetadataRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.OptionsSet == o.OptionsSet && MapObjectEqual(v.Options, o.Options) &&
		v.PublicKeysSet == o.PublicKeysSet && PublicKeySliceEqual(v.PublicKeys, o.PublicKeys)
}

// Reset resets ConstructionMetadataRequest so that it can be reused.
func (v *ConstructionMetadataRequest) Reset() {
	v.NetworkIdentifier.Reset()
	if len(v.Options) > 0 {
		v.Options = v.Options[:0]
	}
	v.OptionsSet = false
	if len(v.PublicKeys) > 0 {
		v.PublicKeys = v.PublicKeys[:0]
	}
	v.PublicKeysSet = false
}

// ConstructionMetadataResponse type.
//
// The ConstructionMetadataResponse returns network-specific metadata used for
// transaction construction.
//
// Optionally, the implementer can return the suggested fee associated with the
// transaction being constructed. The caller may use this info to adjust the
// intent of the transaction or to create a transaction with a different account
// that can pay the suggested fee. Suggested fee is an array in case fee payment
// must occur in multiple currencies.
type ConstructionMetadataResponse struct {
	Metadata        MapObject
	SuggestedFee    []Amount
	SuggestedFeeSet bool
}

// Equal returns whether two ConstructionMetadataResponse values are equal.
func (v ConstructionMetadataResponse) Equal(o ConstructionMetadataResponse) bool {
	return MapObjectEqual(v.Metadata, o.Metadata) &&
		v.SuggestedFeeSet == o.SuggestedFeeSet && AmountSliceEqual(v.SuggestedFee, o.SuggestedFee)
}

// Reset resets ConstructionMetadataResponse so that it can be reused.
func (v *ConstructionMetadataResponse) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	if len(v.SuggestedFee) > 0 {
		v.SuggestedFee = v.SuggestedFee[:0]
	}
	v.SuggestedFeeSet = false
}

// ConstructionParseRequest is the input to the `/construction/parse` endpoint.
// It allows the caller to parse either an unsigned or signed transaction.
type ConstructionParseRequest struct {
	NetworkIdentifier NetworkIdentifier
	// Signed is a boolean indicating whether the transaction is signed.
	Signed bool
	// This must be either the unsigned transaction blob returned by
	// `/construction/payloads` or the signed transaction blob returned by
	// `/construction/combine`.
	Transaction string
}

// Equal returns whether two ConstructionParseRequest values are equal.
func (v ConstructionParseRequest) Equal(o ConstructionParseRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.Signed == o.Signed &&
		v.Transaction == o.Transaction
}

// Reset resets ConstructionParseRequest so that it can be reused.
func (v *ConstructionParseRequest) Reset() {
	v.NetworkIdentifier.Reset()
	v.Signed = false
	v.Transaction = ""
}

// ConstructionParseResponse contains an array of operations that occur in a
// transaction blob. This should match the array of operations provided to
// `/construction/preprocess` and `/construction/payloads`.
type ConstructionParseResponse struct {
	AccountIdentifierSigners    []AccountIdentifier
	AccountIdentifierSignersSet bool
	Metadata                    MapObject
	MetadataSet                 bool
	Operations                  []Operation
	// [DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers
	// (addresses) of a particular transaction. If the transaction is unsigned,
	// it should be empty.
	Signers    []string
	SignersSet bool
}

// Equal returns whether two ConstructionParseResponse values are equal.
func (v ConstructionParseResponse) Equal(o ConstructionParseResponse) bool {
	return v.AccountIdentifierSignersSet == o.AccountIdentifierSignersSet && AccountIdentifierSliceEqual(v.AccountIdentifierSigners, o.AccountIdentifierSigners) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		OperationSliceEqual(v.Operations, o.Operations) &&
		v.SignersSet == o.SignersSet && StringSliceEqual(v.Signers, o.Signers)
}

// Reset resets ConstructionParseResponse so that it can be reused.
func (v *ConstructionParseResponse) Reset() {
	if len(v.AccountIdentifierSigners) > 0 {
		v.AccountIdentifierSigners = v.AccountIdentifierSigners[:0]
	}
	v.AccountIdentifierSignersSet = false
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	if len(v.Operations) > 0 {
		v.Operations = v.Operations[:0]
	}
	if len(v.Signers) > 0 {
		v.Signers = v.Signers[:0]
	}
	v.SignersSet = false
}

// ConstructionPayloadsRequest is the request to `/construction/payloads`. It
// contains the network, a slice of operations, and arbitrary metadata that was
// returned by the call to `/construction/metadata`.
//
// Optionally, the request can also include an array of PublicKeys associated
// with the AccountIdentifiers returned in ConstructionPreprocessResponse.
type ConstructionPayloadsRequest struct {
	Metadata          MapObject
	MetadataSet       bool
	NetworkIdentifier NetworkIdentifier
	Operations        []Operation
	PublicKeys        []PublicKey
	PublicKeysSet     bool
}

// Equal returns whether two ConstructionPayloadsRequest values are equal.
func (v ConstructionPayloadsRequest) Equal(o ConstructionPayloadsRequest) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		OperationSliceEqual(v.Operations, o.Operations) &&
		v.PublicKeysSet == o.PublicKeysSet && PublicKeySliceEqual(v.PublicKeys, o.PublicKeys)
}

// Reset resets ConstructionPayloadsRequest so that it can be reused.
func (v *ConstructionPayloadsRequest) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.NetworkIdentifier.Reset()
	if len(v.Operations) > 0 {
		v.Operations = v.Operations[:0]
	}
	if len(v.PublicKeys) > 0 {
		v.PublicKeys = v.PublicKeys[:0]
	}
	v.PublicKeysSet = false
}

// ConstructionPayloadsResponse type.
//
// ConstructionTransactionResponse is returned by `/construction/payloads`. It
// contains an unsigned transaction blob (that is usually needed to construct
// the a network transaction from a collection of signatures) and an array of
// payloads that must be signed by the caller.
type ConstructionPayloadsResponse struct {
	Payloads            []SigningPayload
	UnsignedTransaction string
}

// Equal returns whether two ConstructionPayloadsResponse values are equal.
func (v ConstructionPayloadsResponse) Equal(o ConstructionPayloadsResponse) bool {
	return SigningPayloadSliceEqual(v.Payloads, o.Payloads) &&
		v.UnsignedTransaction == o.UnsignedTransaction
}

// Reset resets ConstructionPayloadsResponse so that it can be reused.
func (v *ConstructionPayloadsResponse) Reset() {
	if len(v.Payloads) > 0 {
		v.Payloads = v.Payloads[:0]
	}
	v.UnsignedTransaction = ""
}

// ConstructionPreprocessRequest is passed to the `/construction/preprocess`
// endpoint so that a Rosetta implementation can determine which metadata it
// needs to request for construction.
//
// Metadata provided in this object should NEVER be a product of live data (i.e.
// the caller must follow some network-specific data fetching strategy outside
// of the Construction API to populate required Metadata). If live data is
// required for construction, it MUST be fetched in the call to
// `/construction/metadata`.
//
// The caller can provide a max fee they are willing to pay for a transaction.
// This is an array in the case fees must be paid in multiple currencies.
//
// The caller can also provide a suggested fee multiplier to indicate that the
// suggested fee should be scaled. This may be used to set higher fees for
// urgent transactions or to pay lower fees when there is less urgency. It is
// assumed that providing a very low multiplier (like 0.0001) will never lead to
// a transaction being created with a fee less than the minimum network fee (if
// applicable).
//
// In the case that the caller provides both a max fee and a suggested fee
// multiplier, the max fee will set an upper bound on the suggested fee
// (regardless of the multiplier provided).
type ConstructionPreprocessRequest struct {
	MaxFee                    []Amount
	MaxFeeSet                 bool
	Metadata                  MapObject
	MetadataSet               bool
	NetworkIdentifier         NetworkIdentifier
	Operations                []Operation
	SuggestedFeeMultiplier    float64
	SuggestedFeeMultiplierSet bool
}

// Equal returns whether two ConstructionPreprocessRequest values are equal.
func (v ConstructionPreprocessRequest) Equal(o ConstructionPreprocessRequest) bool {
	return v.MaxFeeSet == o.MaxFeeSet && AmountSliceEqual(v.MaxFee, o.MaxFee) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		OperationSliceEqual(v.Operations, o.Operations) &&
		v.SuggestedFeeMultiplierSet == o.SuggestedFeeMultiplierSet && v.SuggestedFeeMultiplier == o.SuggestedFeeMultiplier
}

// Reset resets ConstructionPreprocessRequest so that it can be reused.
func (v *ConstructionPreprocessRequest) Reset() {
	if len(v.MaxFee) > 0 {
		v.MaxFee = v.MaxFee[:0]
	}
	v.MaxFeeSet = false
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.NetworkIdentifier.Reset()
	if len(v.Operations) > 0 {
		v.Operations = v.Operations[:0]
	}
	v.SuggestedFeeMultiplier = 0
	v.SuggestedFeeMultiplierSet = false
}

// ConstructionPreprocessResponse contains `options` that will be sent
// unmodified to `/construction/metadata`. If it is not necessary to make a
// request to `/construction/metadata`, `options` should be omitted.
//
// Some blockchains require the PublicKey of particular AccountIdentifiers to
// construct a valid transaction. To fetch these PublicKeys, populate
// `required_public_keys` with the AccountIdentifiers associated with the
// desired PublicKeys. If it is not necessary to retrieve any PublicKeys for
// construction, `required_public_keys` should be omitted.
type ConstructionPreprocessResponse struct {
	// The options that will be sent directly to `/construction/metadata` by the
	// caller.
	Options               MapObject
	OptionsSet            bool
	RequiredPublicKeys    []AccountIdentifier
	RequiredPublicKeysSet bool
}

// Equal returns whether two ConstructionPreprocessResponse values are equal.
func (v ConstructionPreprocessResponse) Equal(o ConstructionPreprocessResponse) bool {
	return v.OptionsSet == o.OptionsSet && MapObjectEqual(v.Options, o.Options) &&
		v.RequiredPublicKeysSet == o.RequiredPublicKeysSet && AccountIdentifierSliceEqual(v.RequiredPublicKeys, o.RequiredPublicKeys)
}

// Reset resets ConstructionPreprocessResponse so that it can be reused.
func (v *ConstructionPreprocessResponse) Reset() {
	if len(v.Options) > 0 {
		v.Options = v.Options[:0]
	}
	v.OptionsSet = false
	if len(v.RequiredPublicKeys) > 0 {
		v.RequiredPublicKeys = v.RequiredPublicKeys[:0]
	}
	v.RequiredPublicKeysSet = false
}

// ConstructionSubmitRequest type.
//
// The transaction submission request includes a signed transaction.
type ConstructionSubmitRequest struct {
	NetworkIdentifier NetworkIdentifier
	SignedTransaction string
}

// Equal returns whether two ConstructionSubmitRequest values are equal.
func (v ConstructionSubmitRequest) Equal(o ConstructionSubmitRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionSubmitRequest so that it can be reused.
func (v *ConstructionSubmitRequest) Reset() {
	v.NetworkIdentifier.Reset()
	v.SignedTransaction = ""
}

// Currency is composed of a canonical Symbol and Decimals. This Decimals value
// is used to convert an Amount.Value from atomic units (Satoshis) to standard
// units (Bitcoins).
type Currency struct {
	// Number of decimal places in the standard unit representation of the
	// amount.
	//
	// For example, BTC has 8 decimals. Note that it is not possible to
	// represent the value of some currency in atomic units that is not base 10.
	Decimals int32
	// Any additional information related to the currency itself.
	//
	// For example, it would be useful to populate this object with the contract
	// address of an ERC-20 token.
	Metadata    MapObject
	MetadataSet bool
	// Canonical symbol associated with a currency.
	Symbol string
}

// Equal returns whether two Currency values are equal.
func (v Currency) Equal(o Currency) bool {
	return v.Decimals == o.Decimals &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.Symbol == o.Symbol
}

// Reset resets Currency so that it can be reused.
func (v *Currency) Reset() {
	v.Decimals = 0
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.Symbol = ""
}

// CurveType is the type of cryptographic curve associated with a PublicKey.
//
// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
type CurveType string

// Validate the CurveType value.
func (v CurveType) Validate() error {
	if !(v == "edwards25519" || v == "secp256k1" || v == "secp256r1" || v == "tweedle") {
		return fmt.Errorf("api: invalid CurveType value: %q", v)
	}
	return nil
}

// Direction type.
//
// Used by RelatedTransaction to indicate the direction of the relation (i.e.
// cross-shard/cross-network sends may reference `backward` to an earlier
// transaction and async execution may reference `forward`). Can be used to
// indicate if a transaction relation is from child to parent or the reverse.
type Direction string

// Validate the Direction value.
func (v Direction) Validate() error {
	if !(v == "backward" || v == "forward") {
		return fmt.Errorf("api: invalid Direction value: %q", v)
	}
	return nil
}

// Error type.
//
// Instead of utilizing HTTP status codes to describe node errors (which often
// do not have a good analog), rich errors are returned using this object.
//
// Both the code and message fields can be individually used to correctly
// identify an error. Implementations MUST use unique values for both fields.
type Error struct {
	// Code is a network-specific error code. If desired, this code can be
	// equivalent to an HTTP status code.
	Code int32
	// Description allows the implementer to optionally provide additional
	// information about an error. In many cases, the content of this field will
	// be a copy-and-paste from existing developer documentation.
	//
	// Description can ONLY be populated with generic information about a
	// particular type of error. It MUST NOT be populated with information about
	// a particular instantiation of an error (use `details` for this).
	//
	// Whereas the content of Error.Message should stay stable across releases,
	// the content of Error.Description will likely change across releases (as
	// implementers improve error documentation). For this reason, the content
	// in this field is not part of any type assertion (unlike Error.Message).
	Description    string
	DescriptionSet bool
	// Often times it is useful to return context specific to the request that
	// caused the error (i.e. a sample of the stack trace or impacted account)
	// in addition to the standard error message.
	Details    MapObject
	DetailsSet bool
	// Message is a network-specific error message.
	//
	// The message MUST NOT change for a given code. In particular, this means
	// that any contextual information should be included in the details field.
	Message string
	// An error is retriable if the same request may succeed if submitted again.
	Retriable bool
}

// Equal returns whether two Error values are equal.
func (v Error) Equal(o Error) bool {
	return v.Code == o.Code &&
		v.DescriptionSet == o.DescriptionSet && v.Description == o.Description &&
		v.DetailsSet == o.DetailsSet && MapObjectEqual(v.Details, o.Details) &&
		v.Message == o.Message &&
		v.Retriable == o.Retriable
}

// Reset resets Error so that it can be reused.
func (v *Error) Reset() {
	v.Code = 0
	v.Description = ""
	v.DescriptionSet = false
	if len(v.Details) > 0 {
		v.Details = v.Details[:0]
	}
	v.DetailsSet = false
	v.Message = ""
	v.Retriable = false
}

// EventsBlocksRequest is utilized to fetch a sequence of BlockEvents indicating
// which blocks were added and removed from storage to reach the current state.
type EventsBlocksRequest struct {
	// limit is the maximum number of events to fetch in one call. The
	// implementation may return <= limit events.
	Limit             int64
	LimitSet          bool
	NetworkIdentifier NetworkIdentifier
	// offset is the offset into the event stream to sync events from. If this
	// field is not populated, we return the limit events backwards from tip. If
	// this is set to 0, we start from the beginning.
	Offset    int64
	OffsetSet bool
}

// Equal returns whether two EventsBlocksRequest values are equal.
func (v EventsBlocksRequest) Equal(o EventsBlocksRequest) bool {
	return v.LimitSet == o.LimitSet && v.Limit == o.Limit &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.OffsetSet == o.OffsetSet && v.Offset == o.Offset
}

// Reset resets EventsBlocksRequest so that it can be reused.
func (v *EventsBlocksRequest) Reset() {
	v.Limit = 0
	v.LimitSet = false
	v.NetworkIdentifier.Reset()
	v.Offset = 0
	v.OffsetSet = false
}

// EventsBlocksResponse contains an ordered collection of BlockEvents and the
// max retrievable sequence.
type EventsBlocksResponse struct {
	// events is an array of BlockEvents indicating the order to add and remove
	// blocks to maintain a canonical view of blockchain state. Lightweight
	// clients can use this event stream to update state without implementing
	// their own block syncing logic.
	Events []BlockEvent
	// max_sequence is the maximum available sequence number to fetch.
	MaxSequence int64
}

// Equal returns whether two EventsBlocksResponse values are equal.
func (v EventsBlocksResponse) Equal(o EventsBlocksResponse) bool {
	return BlockEventSliceEqual(v.Events, o.Events) &&
		v.MaxSequence == o.MaxSequence
}

// Reset resets EventsBlocksResponse so that it can be reused.
func (v *EventsBlocksResponse) Reset() {
	if len(v.Events) > 0 {
		v.Events = v.Events[:0]
	}
	v.MaxSequence = 0
}

// ExemptionType is used to indicate if the live balance for an account subject
// to a BalanceExemption could increase above, decrease below, or equal the
// computed balance.
//
// * greater_or_equal: The live balance may increase above or equal the computed balance. This typically
// occurs with staking rewards that accrue on each block.
// * less_or_equal: The live balance may decrease below or equal the computed balance. This typically
// occurs as balance moves from locked to spendable on a vesting account.
// * dynamic: The live balance may increase above, decrease below, or equal the computed balance. This
// typically occurs with tokens that have a dynamic supply.
type ExemptionType string

// Validate the ExemptionType value.
func (v ExemptionType) Validate() error {
	if !(v == "dynamic" || v == "greater_or_equal" || v == "less_or_equal") {
		return fmt.Errorf("api: invalid ExemptionType value: %q", v)
	}
	return nil
}

// MempoolResponse type.
//
// A MempoolResponse contains all transaction identifiers in the mempool for a
// particular network_identifier.
type MempoolResponse struct {
	TransactionIdentifiers []TransactionIdentifier
}

// Equal returns whether two MempoolResponse values are equal.
func (v MempoolResponse) Equal(o MempoolResponse) bool {
	return TransactionIdentifierSliceEqual(v.TransactionIdentifiers, o.TransactionIdentifiers)
}

// Reset resets MempoolResponse so that it can be reused.
func (v *MempoolResponse) Reset() {
	if len(v.TransactionIdentifiers) > 0 {
		v.TransactionIdentifiers = v.TransactionIdentifiers[:0]
	}
}

// MempoolTransactionRequest type.
//
// A MempoolTransactionRequest is utilized to retrieve a transaction from the
// mempool.
type MempoolTransactionRequest struct {
	NetworkIdentifier     NetworkIdentifier
	TransactionIdentifier TransactionIdentifier
}

// Equal returns whether two MempoolTransactionRequest values are equal.
func (v MempoolTransactionRequest) Equal(o MempoolTransactionRequest) bool {
	return v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets MempoolTransactionRequest so that it can be reused.
func (v *MempoolTransactionRequest) Reset() {
	v.NetworkIdentifier.Reset()
	v.TransactionIdentifier.Reset()
}

// MempoolTransactionResponse type.
//
// A MempoolTransactionResponse contains an estimate of a mempool transaction.
// It may not be possible to know the full impact of a transaction in the
// mempool (ex: fee paid).
type MempoolTransactionResponse struct {
	Metadata    MapObject
	MetadataSet bool
	Transaction Transaction
}

// Equal returns whether two MempoolTransactionResponse values are equal.
func (v MempoolTransactionResponse) Equal(o MempoolTransactionResponse) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.Transaction.Equal(o.Transaction)
}

// Reset resets MempoolTransactionResponse so that it can be reused.
func (v *MempoolTransactionResponse) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.Transaction.Reset()
}

// MetadataRequest type.
//
// A MetadataRequest is utilized in any request where the only argument is
// optional metadata.
type MetadataRequest struct {
	Metadata    MapObject
	MetadataSet bool
}

// Equal returns whether two MetadataRequest values are equal.
func (v MetadataRequest) Equal(o MetadataRequest) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata)
}

// Reset resets MetadataRequest so that it can be reused.
func (v *MetadataRequest) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
}

// NetworkIdentifier type.
//
// The network_identifier specifies which network a particular object is
// associated with.
type NetworkIdentifier struct {
	Blockchain string
	// If a blockchain has a specific chain-id or network identifier, it should
	// go in this field. It is up to the client to determine which
	// network-specific identifier is mainnet or testnet.
	Network                 string
	SubNetworkIdentifier    SubNetworkIdentifier
	SubNetworkIdentifierSet bool
}

// Equal returns whether two NetworkIdentifier values are equal.
func (v NetworkIdentifier) Equal(o NetworkIdentifier) bool {
	return v.Blockchain == o.Blockchain &&
		v.Network == o.Network &&
		v.SubNetworkIdentifierSet == o.SubNetworkIdentifierSet && v.SubNetworkIdentifier.Equal(o.SubNetworkIdentifier)
}

// Reset resets NetworkIdentifier so that it can be reused.
func (v *NetworkIdentifier) Reset() {
	v.Blockchain = ""
	v.Network = ""
	v.SubNetworkIdentifier.Reset()
	v.SubNetworkIdentifierSet = false
}

// NetworkListResponse type.
//
// A NetworkListResponse contains all NetworkIdentifiers that the node can serve
// information for.
type NetworkListResponse struct {
	NetworkIdentifiers []NetworkIdentifier
}

// Equal returns whether two NetworkListResponse values are equal.
func (v NetworkListResponse) Equal(o NetworkListResponse) bool {
	return NetworkIdentifierSliceEqual(v.NetworkIdentifiers, o.NetworkIdentifiers)
}

// Reset resets NetworkListResponse so that it can be reused.
func (v *NetworkListResponse) Reset() {
	if len(v.NetworkIdentifiers) > 0 {
		v.NetworkIdentifiers = v.NetworkIdentifiers[:0]
	}
}

// NetworkOptionsResponse contains information about the versioning of the node
// and the allowed operation statuses, operation types, and errors.
type NetworkOptionsResponse struct {
	Allow   Allow
	Version Version
}

// Equal returns whether two NetworkOptionsResponse values are equal.
func (v NetworkOptionsResponse) Equal(o NetworkOptionsResponse) bool {
	return v.Allow.Equal(o.Allow) &&
		v.Version.Equal(o.Version)
}

// Reset resets NetworkOptionsResponse so that it can be reused.
func (v *NetworkOptionsResponse) Reset() {
	v.Allow.Reset()
	v.Version.Reset()
}

// NetworkRequest type.
//
// A NetworkRequest is utilized to retrieve some data specific exclusively to a
// NetworkIdentifier.
type NetworkRequest struct {
	Metadata          MapObject
	MetadataSet       bool
	NetworkIdentifier NetworkIdentifier
}

// Equal returns whether two NetworkRequest values are equal.
func (v NetworkRequest) Equal(o NetworkRequest) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier)
}

// Reset resets NetworkRequest so that it can be reused.
func (v *NetworkRequest) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.NetworkIdentifier.Reset()
}

// NetworkStatusResponse contains basic information about the node's view of a
// blockchain network. It is assumed that any BlockIdentifier.Index less than or
// equal to CurrentBlockIdentifier.Index can be queried.
//
// If a Rosetta implementation prunes historical state, it should populate the
// optional `oldest_block_identifier` field with the oldest block available to
// query. If this is not populated, it is assumed that the
// `genesis_block_identifier` is the oldest queryable block.
//
// If a Rosetta implementation performs some pre-sync before it is possible to
// query blocks, sync_status should be populated so that clients can still
// monitor healthiness. Without this field, it may appear that the
// implementation is stuck syncing and needs to be terminated.
type NetworkStatusResponse struct {
	CurrentBlockIdentifier   BlockIdentifier
	CurrentBlockTimestamp    Timestamp
	GenesisBlockIdentifier   BlockIdentifier
	OldestBlockIdentifier    BlockIdentifier
	OldestBlockIdentifierSet bool
	Peers                    []Peer
	SyncStatus               SyncStatus
	SyncStatusSet            bool
}

// Equal returns whether two NetworkStatusResponse values are equal.
func (v NetworkStatusResponse) Equal(o NetworkStatusResponse) bool {
	return v.CurrentBlockIdentifier.Equal(o.CurrentBlockIdentifier) &&
		v.CurrentBlockTimestamp == o.CurrentBlockTimestamp &&
		v.GenesisBlockIdentifier.Equal(o.GenesisBlockIdentifier) &&
		v.OldestBlockIdentifierSet == o.OldestBlockIdentifierSet && v.OldestBlockIdentifier.Equal(o.OldestBlockIdentifier) &&
		PeerSliceEqual(v.Peers, o.Peers) &&
		v.SyncStatusSet == o.SyncStatusSet && v.SyncStatus.Equal(o.SyncStatus)
}

// Reset resets NetworkStatusResponse so that it can be reused.
func (v *NetworkStatusResponse) Reset() {
	v.CurrentBlockIdentifier.Reset()
	v.CurrentBlockTimestamp = 0
	v.GenesisBlockIdentifier.Reset()
	v.OldestBlockIdentifier.Reset()
	v.OldestBlockIdentifierSet = false
	if len(v.Peers) > 0 {
		v.Peers = v.Peers[:0]
	}
	v.SyncStatus.Reset()
	v.SyncStatusSet = false
}

// Operation type.
//
// Operations contain all balance-changing information within a transaction.
// They are always one-sided (only affect 1 AccountIdentifier) and can succeed
// or fail independently from a Transaction.
//
// Operations are used both to represent on-chain data (Data API) and to
// construct new transactions (Construction API), creating a standard interface
// for reading and writing to blockchains.
type Operation struct {
	Account             AccountIdentifier
	AccountSet          bool
	Amount              Amount
	AmountSet           bool
	CoinChange          CoinChange
	CoinChangeSet       bool
	Metadata            MapObject
	MetadataSet         bool
	OperationIdentifier OperationIdentifier
	// Restrict referenced related_operations to identifier indices < the
	// current operation_identifier.index. This ensures there exists a clear
	// DAG-structure of relations.
	//
	// Since operations are one-sided, one could imagine relating operations in
	// a single transfer or linking operations in a call tree.
	RelatedOperations    []OperationIdentifier
	RelatedOperationsSet bool
	// Status is the network-specific status of the operation. Status is not
	// defined on the transaction object because blockchains with smart
	// contracts may have transactions that partially apply (some operations are
	// successful and some are not). Blockchains with atomic transactions (all
	// operations succeed or all operations fail) will have the same status for
	// each operation.
	//
	// On-chain operations (operations retrieved in the `/block` and
	// `/block/transaction` endpoints) MUST have a populated status field
	// (anything on-chain must have succeeded or failed). However, operations
	// provided during transaction construction (often times called "intent" in
	// the documentation) MUST NOT have a populated status field (operations yet
	// to be included on-chain have not yet succeeded or failed).
	Status    string
	StatusSet bool
	// Type is the network-specific type of the operation. Ensure that any type
	// that can be returned here is also specified in the
	// NetworkOptionsResponse. This can be very useful to downstream consumers
	// that parse all block data.
	Type string
}

// Equal returns whether two Operation values are equal.
func (v Operation) Equal(o Operation) bool {
	return v.AccountSet == o.AccountSet && v.Account.Equal(o.Account) &&
		v.AmountSet == o.AmountSet && v.Amount.Equal(o.Amount) &&
		v.CoinChangeSet == o.CoinChangeSet && v.CoinChange.Equal(o.CoinChange) &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.OperationIdentifier.Equal(o.OperationIdentifier) &&
		v.RelatedOperationsSet == o.RelatedOperationsSet && OperationIdentifierSliceEqual(v.RelatedOperations, o.RelatedOperations) &&
		v.StatusSet == o.StatusSet && v.Status == o.Status &&
		v.Type == o.Type
}

// Reset resets Operation so that it can be reused.
func (v *Operation) Reset() {
	v.Account.Reset()
	v.AccountSet = false
	v.Amount.Reset()
	v.AmountSet = false
	v.CoinChange.Reset()
	v.CoinChangeSet = false
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.OperationIdentifier.Reset()
	if len(v.RelatedOperations) > 0 {
		v.RelatedOperations = v.RelatedOperations[:0]
	}
	v.RelatedOperationsSet = false
	v.Status = ""
	v.StatusSet = false
	v.Type = ""
}

// OperationIdentifier type.
//
// The operation_identifier uniquely identifies an operation within a
// transaction.
type OperationIdentifier struct {
	// The operation index is used to ensure each operation has a unique
	// identifier within a transaction. This index is only relative to the
	// transaction and NOT GLOBAL. The operations in each transaction should
	// start from index 0.
	//
	// To clarify, there may not be any notion of an operation index in the
	// blockchain being described.
	Index int64
	// Some blockchains specify an operation index that is essential for client
	// use. For example, Bitcoin uses a network_index to identify which UTXO was
	// used in a transaction.
	//
	// network_index should not be populated if there is no notion of an
	// operation index in a blockchain (typically most account-based
	// blockchains).
	NetworkIndex    int64
	NetworkIndexSet bool
}

// Equal returns whether two OperationIdentifier values are equal.
func (v OperationIdentifier) Equal(o OperationIdentifier) bool {
	return v.Index == o.Index &&
		v.NetworkIndexSet == o.NetworkIndexSet && v.NetworkIndex == o.NetworkIndex
}

// Reset resets OperationIdentifier so that it can be reused.
func (v *OperationIdentifier) Reset() {
	v.Index = 0
	v.NetworkIndex = 0
	v.NetworkIndexSet = false
}

// OperationStatus is utilized to indicate which Operation status are considered
// successful.
type OperationStatus struct {
	// The status is the network-specific status of the operation.
	Status string
	// An Operation is considered successful if the Operation.Amount should
	// affect the Operation.Account. Some blockchains (like Bitcoin) only
	// include successful operations in blocks but other blockchains (like
	// Ethereum) include unsuccessful operations that incur a fee.
	//
	// To reconcile the computed balance from the stream of Operations, it is
	// critical to understand which Operation.Status indicate an Operation is
	// successful and should affect an Account.
	Successful bool
}

// Equal returns whether two OperationStatus values are equal.
func (v OperationStatus) Equal(o OperationStatus) bool {
	return v.Status == o.Status &&
		v.Successful == o.Successful
}

// Reset resets OperationStatus so that it can be reused.
func (v *OperationStatus) Reset() {
	v.Status = ""
	v.Successful = false
}

// Operator is used by query-related endpoints to determine how to apply
// conditions.
//
// If this field is not populated, the default `and` value will be used.
type Operator string

// Validate the Operator value.
func (v Operator) Validate() error {
	if !(v == "and" || v == "or") {
		return fmt.Errorf("api: invalid Operator value: %q", v)
	}
	return nil
}

// PartialBlockIdentifier type.
//
// When fetching data by BlockIdentifier, it may be possible to only specify the
// index or hash. If neither property is specified, it is assumed that the
// client is making a request at the current block.
type PartialBlockIdentifier struct {
	Hash     string
	HashSet  bool
	Index    int64
	IndexSet bool
}

// Equal returns whether two PartialBlockIdentifier values are equal.
func (v PartialBlockIdentifier) Equal(o PartialBlockIdentifier) bool {
	return v.HashSet == o.HashSet && v.Hash == o.Hash &&
		v.IndexSet == o.IndexSet && v.Index == o.Index
}

// Reset resets PartialBlockIdentifier so that it can be reused.
func (v *PartialBlockIdentifier) Reset() {
	v.Hash = ""
	v.HashSet = false
	v.Index = 0
	v.IndexSet = false
}

// Peer type.
//
// A Peer is a representation of a node's peer.
type Peer struct {
	Metadata    MapObject
	MetadataSet bool
	PeerID      string
}

// Equal returns whether two Peer values are equal.
func (v Peer) Equal(o Peer) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.PeerID == o.PeerID
}

// Reset resets Peer so that it can be reused.
func (v *Peer) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.PeerID = ""
}

// PublicKey contains a public key byte array for a particular CurveType encoded
// in hex.
//
// Note that there is no PrivateKey struct as this is NEVER the concern of an
// implementation.
type PublicKey struct {
	// Hex-encoded public key bytes in the format specified by the CurveType.
	Bytes     []byte
	CurveType CurveType
}

// Equal returns whether two PublicKey values are equal.
func (v PublicKey) Equal(o PublicKey) bool {
	return bytes.Equal(v.Bytes, o.Bytes) &&
		v.CurveType == o.CurveType
}

// Reset resets PublicKey so that it can be reused.
func (v *PublicKey) Reset() {
	if len(v.Bytes) > 0 {
		v.Bytes = v.Bytes[:0]
	}
	v.CurveType = ""
}

// RelatedTransaction type.
//
// The related_transaction allows implementations to link together multiple
// transactions. An unpopulated network identifier indicates that the related
// transaction is on the same network.
type RelatedTransaction struct {
	Direction             Direction
	NetworkIdentifier     NetworkIdentifier
	NetworkIdentifierSet  bool
	TransactionIdentifier TransactionIdentifier
}

// Equal returns whether two RelatedTransaction values are equal.
func (v RelatedTransaction) Equal(o RelatedTransaction) bool {
	return v.Direction == o.Direction &&
		v.NetworkIdentifierSet == o.NetworkIdentifierSet && v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets RelatedTransaction so that it can be reused.
func (v *RelatedTransaction) Reset() {
	v.Direction = ""
	v.NetworkIdentifier.Reset()
	v.NetworkIdentifierSet = false
	v.TransactionIdentifier.Reset()
}

// SearchTransactionsRequest is used to search for transactions matching a set
// of provided conditions in canonical blocks.
type SearchTransactionsRequest struct {
	AccountIdentifier    AccountIdentifier
	AccountIdentifierSet bool
	// address is AccountIdentifier.Address. This is used to get all
	// transactions related to an AccountIdentifier.Address, regardless of
	// SubAccountIdentifier.
	Address           string
	AddressSet        bool
	CoinIdentifier    CoinIdentifier
	CoinIdentifierSet bool
	Currency          Currency
	CurrencySet       bool
	// limit is the maximum number of transactions to return in one call. The
	// implementation may return <= limit transactions.
	Limit    int64
	LimitSet bool
	// max_block is the largest block index to consider when searching for
	// transactions. If this field is not populated, the current block is
	// considered the max_block.
	//
	// If you do not specify a max_block, it is possible a newly synced block
	// will interfere with paginated transaction queries (as the offset could
	// become invalid with newly added rows).
	MaxBlock          int64
	MaxBlockSet       bool
	NetworkIdentifier NetworkIdentifier
	// offset is the offset into the query result to start returning
	// transactions.
	//
	// If any search conditions are changed, the query offset will change and
	// you must restart your search iteration.
	Offset      int64
	OffsetSet   bool
	Operator    Operator
	OperatorSet bool
	// status is the network-specific operation type.
	Status    string
	StatusSet bool
	// success is a synthetic condition populated by parsing network-specific
	// operation statuses (using the mapping provided in `/network/options`).
	Success                  bool
	SuccessSet               bool
	TransactionIdentifier    TransactionIdentifier
	TransactionIdentifierSet bool
	// type is the network-specific operation type.
	Type    string
	TypeSet bool
}

// Equal returns whether two SearchTransactionsRequest values are equal.
func (v SearchTransactionsRequest) Equal(o SearchTransactionsRequest) bool {
	return v.AccountIdentifierSet == o.AccountIdentifierSet && v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.AddressSet == o.AddressSet && v.Address == o.Address &&
		v.CoinIdentifierSet == o.CoinIdentifierSet && v.CoinIdentifier.Equal(o.CoinIdentifier) &&
		v.CurrencySet == o.CurrencySet && v.Currency.Equal(o.Currency) &&
		v.LimitSet == o.LimitSet && v.Limit == o.Limit &&
		v.MaxBlockSet == o.MaxBlockSet && v.MaxBlock == o.MaxBlock &&
		v.NetworkIdentifier.Equal(o.NetworkIdentifier) &&
		v.OffsetSet == o.OffsetSet && v.Offset == o.Offset &&
		v.OperatorSet == o.OperatorSet && v.Operator == o.Operator &&
		v.StatusSet == o.StatusSet && v.Status == o.Status &&
		v.SuccessSet == o.SuccessSet && v.Success == o.Success &&
		v.TransactionIdentifierSet == o.TransactionIdentifierSet && v.TransactionIdentifier.Equal(o.TransactionIdentifier) &&
		v.TypeSet == o.TypeSet && v.Type == o.Type
}

// Reset resets SearchTransactionsRequest so that it can be reused.
func (v *SearchTransactionsRequest) Reset() {
	v.AccountIdentifier.Reset()
	v.AccountIdentifierSet = false
	v.Address = ""
	v.AddressSet = false
	v.CoinIdentifier.Reset()
	v.CoinIdentifierSet = false
	v.Currency.Reset()
	v.CurrencySet = false
	v.Limit = 0
	v.LimitSet = false
	v.MaxBlock = 0
	v.MaxBlockSet = false
	v.NetworkIdentifier.Reset()
	v.Offset = 0
	v.OffsetSet = false
	v.Operator = ""
	v.OperatorSet = false
	v.Status = ""
	v.StatusSet = false
	v.Success = false
	v.SuccessSet = false
	v.TransactionIdentifier.Reset()
	v.TransactionIdentifierSet = false
	v.Type = ""
	v.TypeSet = false
}

// SearchTransactionsResponse contains an ordered collection of
// BlockTransactions that match the query in SearchTransactionsRequest. These
// BlockTransactions are sorted from most recent block to oldest block.
type SearchTransactionsResponse struct {
	// next_offset is the next offset to use when paginating through transaction
	// results. If this field is not populated, there are no more transactions
	// to query.
	NextOffset    int64
	NextOffsetSet bool
	// total_count is the number of results for a given search. Callers
	// typically use this value to concurrently fetch results by offset or to
	// display a virtual page number associated with results.
	TotalCount int64
	// transactions is an array of BlockTransactions sorted by most recent
	// BlockIdentifier (meaning that transactions in recent blocks appear
	// first).
	//
	// If there are many transactions for a particular search, transactions may
	// not contain all matching transactions. It is up to the caller to paginate
	// these transactions using the max_block field.
	Transactions []BlockTransaction
}

// Equal returns whether two SearchTransactionsResponse values are equal.
func (v SearchTransactionsResponse) Equal(o SearchTransactionsResponse) bool {
	return v.NextOffsetSet == o.NextOffsetSet && v.NextOffset == o.NextOffset &&
		v.TotalCount == o.TotalCount &&
		BlockTransactionSliceEqual(v.Transactions, o.Transactions)
}

// Reset resets SearchTransactionsResponse so that it can be reused.
func (v *SearchTransactionsResponse) Reset() {
	v.NextOffset = 0
	v.NextOffsetSet = false
	v.TotalCount = 0
	if len(v.Transactions) > 0 {
		v.Transactions = v.Transactions[:0]
	}
}

// Signature contains the payload that was signed, the public keys of the
// keypairs used to produce the signature, the signature (encoded in hex), and
// the SignatureType.
//
// PublicKey is often times not known during construction of the signing
// payloads but may be needed to combine signatures properly.
type Signature struct {
	Bytes          []byte
	PublicKey      PublicKey
	SignatureType  SignatureType
	SigningPayload SigningPayload
}

// Equal returns whether two Signature values are equal.
func (v Signature) Equal(o Signature) bool {
	return bytes.Equal(v.Bytes, o.Bytes) &&
		v.PublicKey.Equal(o.PublicKey) &&
		v.SignatureType == o.SignatureType &&
		v.SigningPayload.Equal(o.SigningPayload)
}

// Reset resets Signature so that it can be reused.
func (v *Signature) Reset() {
	if len(v.Bytes) > 0 {
		v.Bytes = v.Bytes[:0]
	}
	v.PublicKey.Reset()
	v.SignatureType = ""
	v.SigningPayload.Reset()
}

// SignatureType is the type of a cryptographic signature.
//
// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
type SignatureType string

// Validate the SignatureType value.
func (v SignatureType) Validate() error {
	if !(v == "ecdsa" || v == "ecdsa_recovery" || v == "ed25519" || v == "schnorr_1" || v == "schnorr_poseidon") {
		return fmt.Errorf("api: invalid SignatureType value: %q", v)
	}
	return nil
}

// SigningPayload is signed by the client with the keypair associated with an
// AccountIdentifier using the specified SignatureType.
//
// SignatureType can be optionally populated if there is a restriction on the
// signature scheme that can be used to sign the payload.
type SigningPayload struct {
	AccountIdentifier    AccountIdentifier
	AccountIdentifierSet bool
	// [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific
	// address of the account that should sign the payload.
	Address          string
	AddressSet       bool
	Bytes            []byte
	SignatureType    SignatureType
	SignatureTypeSet bool
}

// Equal returns whether two SigningPayload values are equal.
func (v SigningPayload) Equal(o SigningPayload) bool {
	return v.AccountIdentifierSet == o.AccountIdentifierSet && v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.AddressSet == o.AddressSet && v.Address == o.Address &&
		bytes.Equal(v.Bytes, o.Bytes) &&
		v.SignatureTypeSet == o.SignatureTypeSet && v.SignatureType == o.SignatureType
}

// Reset resets SigningPayload so that it can be reused.
func (v *SigningPayload) Reset() {
	v.AccountIdentifier.Reset()
	v.AccountIdentifierSet = false
	v.Address = ""
	v.AddressSet = false
	if len(v.Bytes) > 0 {
		v.Bytes = v.Bytes[:0]
	}
	v.SignatureType = ""
	v.SignatureTypeSet = false
}

// SubAccountIdentifier type.
//
// An account may have state specific to a contract address (ERC-20 token)
// and/or a stake (delegated balance). The sub_account_identifier should specify
// which state (if applicable) an account instantiation refers to.
type SubAccountIdentifier struct {
	// The SubAccount address may be a cryptographic value or some other
	// identifier (ex: bonded) that uniquely specifies a SubAccount.
	Address string
	// If the SubAccount address is not sufficient to uniquely specify a
	// SubAccount, any other identifying information can be stored here.
	//
	// It is important to note that two SubAccounts with identical addresses but
	// differing metadata will not be considered equal by clients.
	Metadata    MapObject
	MetadataSet bool
}

// Equal returns whether two SubAccountIdentifier values are equal.
func (v SubAccountIdentifier) Equal(o SubAccountIdentifier) bool {
	return v.Address == o.Address &&
		v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata)
}

// Reset resets SubAccountIdentifier so that it can be reused.
func (v *SubAccountIdentifier) Reset() {
	v.Address = ""
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
}

// SubNetworkIdentifier type.
//
// In blockchains with sharded state, the SubNetworkIdentifier is required to
// query some object on a specific shard. This identifier is optional for all
// non-sharded blockchains.
type SubNetworkIdentifier struct {
	Metadata    MapObject
	MetadataSet bool
	Network     string
}

// Equal returns whether two SubNetworkIdentifier values are equal.
func (v SubNetworkIdentifier) Equal(o SubNetworkIdentifier) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.Network == o.Network
}

// Reset resets SubNetworkIdentifier so that it can be reused.
func (v *SubNetworkIdentifier) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.Network = ""
}

// SyncStatus is used to provide additional context about an implementation's
// sync status.
//
// This object is often used by implementations to indicate healthiness when
// block data cannot be queried until some sync phase completes or cannot be
// determined by comparing the timestamp of the most recent block with the
// current time.
type SyncStatus struct {
	// CurrentIndex is the index of the last synced block in the current stage.
	//
	// This is a separate field from current_block_identifier in
	// NetworkStatusResponse because blocks with indices up to and including the
	// current_index may not yet be queryable by the caller. To reiterate, all
	// indices up to and including current_block_identifier in
	// NetworkStatusResponse must be queryable via the /block endpoint
	// (excluding indices less than oldest_block_identifier).
	CurrentIndex    int64
	CurrentIndexSet bool
	// Stage is the phase of the sync process.
	Stage    string
	StageSet bool
	// sycned is a boolean that indicates if an implementation has synced up to
	// the most recent block. If this field is not populated, the caller should
	// rely on a traditional tip timestamp comparison to determine if an
	// implementation is synced.
	//
	// This field is particularly useful for quiescent blockchains (blocks only
	// produced when there are pending transactions). In these blockchains, the
	// most recent block could have a timestamp far behind the current time but
	// the node could be healthy and at tip.
	Synced    bool
	SyncedSet bool
	// TargetIndex is the index of the block that the implementation is
	// attempting to sync to in the current stage.
	TargetIndex    int64
	TargetIndexSet bool
}

// Equal returns whether two SyncStatus values are equal.
func (v SyncStatus) Equal(o SyncStatus) bool {
	return v.CurrentIndexSet == o.CurrentIndexSet && v.CurrentIndex == o.CurrentIndex &&
		v.StageSet == o.StageSet && v.Stage == o.Stage &&
		v.SyncedSet == o.SyncedSet && v.Synced == o.Synced &&
		v.TargetIndexSet == o.TargetIndexSet && v.TargetIndex == o.TargetIndex
}

// Reset resets SyncStatus so that it can be reused.
func (v *SyncStatus) Reset() {
	v.CurrentIndex = 0
	v.CurrentIndexSet = false
	v.Stage = ""
	v.StageSet = false
	v.Synced = false
	v.SyncedSet = false
	v.TargetIndex = 0
	v.TargetIndexSet = false
}

// Timestamp type.
//
// The timestamp of the block in milliseconds since the Unix Epoch. The
// timestamp is stored in milliseconds because some blockchains produce blocks
// more often than once a second.
type Timestamp int64

// Validate the Timestamp value.
func (v Timestamp) Validate() error {
	if v < 0 {
		return fmt.Errorf("api: Timestamp value cannot be negative: %d", v)
	}
	return nil
}

// Transaction type.
//
// Transactions contain an array of Operations that are attributable to the same
// TransactionIdentifier.
type Transaction struct {
	// Transactions that are related to other transactions (like a cross-shard
	// transaction) should include the tranaction_identifier of these
	// transactions in the metadata.
	Metadata               MapObject
	MetadataSet            bool
	Operations             []Operation
	RelatedTransactions    []RelatedTransaction
	RelatedTransactionsSet bool
	TransactionIdentifier  TransactionIdentifier
}

// Equal returns whether two Transaction values are equal.
func (v Transaction) Equal(o Transaction) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		OperationSliceEqual(v.Operations, o.Operations) &&
		v.RelatedTransactionsSet == o.RelatedTransactionsSet && RelatedTransactionSliceEqual(v.RelatedTransactions, o.RelatedTransactions) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets Transaction so that it can be reused.
func (v *Transaction) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	if len(v.Operations) > 0 {
		v.Operations = v.Operations[:0]
	}
	if len(v.RelatedTransactions) > 0 {
		v.RelatedTransactions = v.RelatedTransactions[:0]
	}
	v.RelatedTransactionsSet = false
	v.TransactionIdentifier.Reset()
}

// TransactionIdentifier type.
//
// The transaction_identifier uniquely identifies a transaction in a particular
// network and block or in the mempool.
type TransactionIdentifier struct {
	// Any transactions that are attributable only to a block (ex: a block
	// event) should use the hash of the block as the identifier.
	Hash string
}

// Equal returns whether two TransactionIdentifier values are equal.
func (v TransactionIdentifier) Equal(o TransactionIdentifier) bool {
	return v.Hash == o.Hash
}

// Reset resets TransactionIdentifier so that it can be reused.
func (v *TransactionIdentifier) Reset() {
	v.Hash = ""
}

// TransactionIdentifierResponse contains the transaction_identifier of a
// transaction that was submitted to either `/construction/hash` or
// `/construction/submit`.
type TransactionIdentifierResponse struct {
	Metadata              MapObject
	MetadataSet           bool
	TransactionIdentifier TransactionIdentifier
}

// Equal returns whether two TransactionIdentifierResponse values are equal.
func (v TransactionIdentifierResponse) Equal(o TransactionIdentifierResponse) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets TransactionIdentifierResponse so that it can be reused.
func (v *TransactionIdentifierResponse) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.TransactionIdentifier.Reset()
}

// Version type.
//
// The Version object is utilized to inform the client of the versions of
// different components of the Rosetta implementation.
type Version struct {
	// Any other information that may be useful about versioning of dependent
	// services should be returned here.
	Metadata    MapObject
	MetadataSet bool
	// When a middleware server is used to adhere to the Rosetta interface, it
	// should return its version here. This can help clients manage deployments.
	MiddlewareVersion    string
	MiddlewareVersionSet bool
	// The node_version is the canonical version of the node runtime. This can
	// help clients manage deployments.
	NodeVersion string
	// The rosetta_version is the version of the Rosetta interface the
	// implementation adheres to. This can be useful for clients looking to
	// reliably parse responses.
	RosettaVersion string
}

// Equal returns whether two Version values are equal.
func (v Version) Equal(o Version) bool {
	return v.MetadataSet == o.MetadataSet && MapObjectEqual(v.Metadata, o.Metadata) &&
		v.MiddlewareVersionSet == o.MiddlewareVersionSet && v.MiddlewareVersion == o.MiddlewareVersion &&
		v.NodeVersion == o.NodeVersion &&
		v.RosettaVersion == o.RosettaVersion
}

// Reset resets Version so that it can be reused.
func (v *Version) Reset() {
	if len(v.Metadata) > 0 {
		v.Metadata = v.Metadata[:0]
	}
	v.MetadataSet = false
	v.MiddlewareVersion = ""
	v.MiddlewareVersionSet = false
	v.NodeVersion = ""
	v.RosettaVersion = ""
}

// AccountIdentifierSliceEqual returns whether the given AccountIdentifier slice values are equal.
func AccountIdentifierSliceEqual(a, b []AccountIdentifier) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// AmountSliceEqual returns whether the given Amount slice values are equal.
func AmountSliceEqual(a, b []Amount) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// BalanceExemptionSliceEqual returns whether the given BalanceExemption slice values are equal.
func BalanceExemptionSliceEqual(a, b []BalanceExemption) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// BlockEventSliceEqual returns whether the given BlockEvent slice values are equal.
func BlockEventSliceEqual(a, b []BlockEvent) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// BlockTransactionSliceEqual returns whether the given BlockTransaction slice values are equal.
func BlockTransactionSliceEqual(a, b []BlockTransaction) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// CoinSliceEqual returns whether the given Coin slice values are equal.
func CoinSliceEqual(a, b []Coin) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// CurrencySliceEqual returns whether the given Currency slice values are equal.
func CurrencySliceEqual(a, b []Currency) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// ErrorSliceEqual returns whether the given Error slice values are equal.
func ErrorSliceEqual(a, b []Error) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// NetworkIdentifierSliceEqual returns whether the given NetworkIdentifier slice values are equal.
func NetworkIdentifierSliceEqual(a, b []NetworkIdentifier) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// OperationSliceEqual returns whether the given Operation slice values are equal.
func OperationSliceEqual(a, b []Operation) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// OperationIdentifierSliceEqual returns whether the given OperationIdentifier slice values are equal.
func OperationIdentifierSliceEqual(a, b []OperationIdentifier) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// OperationStatusSliceEqual returns whether the given OperationStatus slice values are equal.
func OperationStatusSliceEqual(a, b []OperationStatus) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// PeerSliceEqual returns whether the given Peer slice values are equal.
func PeerSliceEqual(a, b []Peer) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// PublicKeySliceEqual returns whether the given PublicKey slice values are equal.
func PublicKeySliceEqual(a, b []PublicKey) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// RelatedTransactionSliceEqual returns whether the given RelatedTransaction slice values are equal.
func RelatedTransactionSliceEqual(a, b []RelatedTransaction) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// SignatureSliceEqual returns whether the given Signature slice values are equal.
func SignatureSliceEqual(a, b []Signature) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// SigningPayloadSliceEqual returns whether the given SigningPayload slice values are equal.
func SigningPayloadSliceEqual(a, b []SigningPayload) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// TransactionSliceEqual returns whether the given Transaction slice values are equal.
func TransactionSliceEqual(a, b []Transaction) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

// TransactionIdentifierSliceEqual returns whether the given TransactionIdentifier slice values are equal.
func TransactionIdentifierSliceEqual(a, b []TransactionIdentifier) bool {
	if len(a) != len(b) {
		return false
	}
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}
