// DO NOT EDIT.
// Generated by running: go run cmd/genapi/genapi.go

// Copyright 2021 Coinbase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package api provides a client for Rosetta API servers.
package api

import (
	"fmt"

	"github.com/tav/validate-rosetta/json"
)

// BlockEventType values.
const (
	BlockAdded   BlockEventType = "block_added"
	BlockRemoved BlockEventType = "block_removed"
)

// CoinAction values.
const (
	CoinCreated CoinAction = "coin_created"
	CoinSpent   CoinAction = "coin_spent"
)

// CurveType values.
const (
	Edwards25519 CurveType = "edwards25519"
	Secp256k1    CurveType = "secp256k1"
	Secp256r1    CurveType = "secp256r1"
	Tweedle      CurveType = "tweedle"
)

// Direction values.
const (
	Backward Direction = "backward"
	Forward  Direction = "forward"
)

// ExemptionType values.
const (
	Dynamic        ExemptionType = "dynamic"
	GreaterOrEqual ExemptionType = "greater_or_equal"
	LessOrEqual    ExemptionType = "less_or_equal"
)

// Operator values.
const (
	And Operator = "and"
	Or  Operator = "or"
)

// SignatureType values.
const (
	ECDSA           SignatureType = "ecdsa"
	ECDSARecovery   SignatureType = "ecdsa_recovery"
	Ed25519         SignatureType = "ed25519"
	Schnorr1        SignatureType = "schnorr_1"
	SchnorrPoseidon SignatureType = "schnorr_poseidon"
)

// Client handles requests to Rosetta API servers.
//
// A Client can only be used to do one API call at a time. That is, do not
// re-use a Client while a previous call is still being handled.
type Client struct {
	baseURL string
}

// OptionalAccountIdentifierType encapsulates an optional AccountIdentifier value.
type OptionalAccountIdentifierType struct {
	Set   bool
	Value AccountIdentifier
}

// OptionalAmountType encapsulates an optional Amount value.
type OptionalAmountType struct {
	Set   bool
	Value Amount
}

// OptionalBlockType encapsulates an optional Block value.
type OptionalBlockType struct {
	Set   bool
	Value Block
}

// OptionalBlockIdentifierType encapsulates an optional BlockIdentifier value.
type OptionalBlockIdentifierType struct {
	Set   bool
	Value BlockIdentifier
}

// OptionalBoolType encapsulates an optional bool value.
type OptionalBoolType struct {
	Set   bool
	Value bool
}

// OptionalCoinChangeType encapsulates an optional CoinChange value.
type OptionalCoinChangeType struct {
	Set   bool
	Value CoinChange
}

// OptionalCoinIdentifierType encapsulates an optional CoinIdentifier value.
type OptionalCoinIdentifierType struct {
	Set   bool
	Value CoinIdentifier
}

// OptionalCurrencyType encapsulates an optional Currency value.
type OptionalCurrencyType struct {
	Set   bool
	Value Currency
}

// OptionalExemptionTypeType encapsulates an optional ExemptionType value.
type OptionalExemptionTypeType struct {
	Set   bool
	Value ExemptionType
}

// OptionalFloat64Type encapsulates an optional float64 value.
type OptionalFloat64Type struct {
	Set   bool
	Value float64
}

// OptionalInt64Type encapsulates an optional int64 value.
type OptionalInt64Type struct {
	Set   bool
	Value int64
}

// OptionalNetworkIdentifierType encapsulates an optional NetworkIdentifier value.
type OptionalNetworkIdentifierType struct {
	Set   bool
	Value NetworkIdentifier
}

// OptionalOperatorType encapsulates an optional Operator value.
type OptionalOperatorType struct {
	Set   bool
	Value Operator
}

// OptionalPartialBlockIdentifierType encapsulates an optional PartialBlockIdentifier value.
type OptionalPartialBlockIdentifierType struct {
	Set   bool
	Value PartialBlockIdentifier
}

// OptionalSignatureTypeType encapsulates an optional SignatureType value.
type OptionalSignatureTypeType struct {
	Set   bool
	Value SignatureType
}

// OptionalStringType encapsulates an optional string value.
type OptionalStringType struct {
	Set   bool
	Value string
}

// OptionalSubAccountIdentifierType encapsulates an optional SubAccountIdentifier value.
type OptionalSubAccountIdentifierType struct {
	Set   bool
	Value SubAccountIdentifier
}

// OptionalSubNetworkIdentifierType encapsulates an optional SubNetworkIdentifier value.
type OptionalSubNetworkIdentifierType struct {
	Set   bool
	Value SubNetworkIdentifier
}

// OptionalSyncStatusType encapsulates an optional SyncStatus value.
type OptionalSyncStatusType struct {
	Set   bool
	Value SyncStatus
}

// OptionalTransactionIdentifierType encapsulates an optional TransactionIdentifier value.
type OptionalTransactionIdentifierType struct {
	Set   bool
	Value TransactionIdentifier
}

// OptionalAccountIdentifier creates an optional AccountIdentifier value.
func OptionalAccountIdentifier(v AccountIdentifier) OptionalAccountIdentifierType {
	return OptionalAccountIdentifierType{true, v}
}

// OptionalAmount creates an optional Amount value.
func OptionalAmount(v Amount) OptionalAmountType {
	return OptionalAmountType{true, v}
}

// OptionalBlock creates an optional Block value.
func OptionalBlock(v Block) OptionalBlockType {
	return OptionalBlockType{true, v}
}

// OptionalBlockIdentifier creates an optional BlockIdentifier value.
func OptionalBlockIdentifier(v BlockIdentifier) OptionalBlockIdentifierType {
	return OptionalBlockIdentifierType{true, v}
}

// OptionalBool creates an optional bool value.
func OptionalBool(v bool) OptionalBoolType {
	return OptionalBoolType{true, v}
}

// OptionalCoinChange creates an optional CoinChange value.
func OptionalCoinChange(v CoinChange) OptionalCoinChangeType {
	return OptionalCoinChangeType{true, v}
}

// OptionalCoinIdentifier creates an optional CoinIdentifier value.
func OptionalCoinIdentifier(v CoinIdentifier) OptionalCoinIdentifierType {
	return OptionalCoinIdentifierType{true, v}
}

// OptionalCurrency creates an optional Currency value.
func OptionalCurrency(v Currency) OptionalCurrencyType {
	return OptionalCurrencyType{true, v}
}

// OptionalExemptionType creates an optional ExemptionType value.
func OptionalExemptionType(v ExemptionType) OptionalExemptionTypeType {
	return OptionalExemptionTypeType{true, v}
}

// OptionalFloat64 creates an optional float64 value.
func OptionalFloat64(v float64) OptionalFloat64Type {
	return OptionalFloat64Type{true, v}
}

// OptionalInt64 creates an optional int64 value.
func OptionalInt64(v int64) OptionalInt64Type {
	return OptionalInt64Type{true, v}
}

// OptionalNetworkIdentifier creates an optional NetworkIdentifier value.
func OptionalNetworkIdentifier(v NetworkIdentifier) OptionalNetworkIdentifierType {
	return OptionalNetworkIdentifierType{true, v}
}

// OptionalOperator creates an optional Operator value.
func OptionalOperator(v Operator) OptionalOperatorType {
	return OptionalOperatorType{true, v}
}

// OptionalPartialBlockIdentifier creates an optional PartialBlockIdentifier value.
func OptionalPartialBlockIdentifier(v PartialBlockIdentifier) OptionalPartialBlockIdentifierType {
	return OptionalPartialBlockIdentifierType{true, v}
}

// OptionalSignatureType creates an optional SignatureType value.
func OptionalSignatureType(v SignatureType) OptionalSignatureTypeType {
	return OptionalSignatureTypeType{true, v}
}

// OptionalString creates an optional string value.
func OptionalString(v string) OptionalStringType {
	return OptionalStringType{true, v}
}

// OptionalSubAccountIdentifier creates an optional SubAccountIdentifier value.
func OptionalSubAccountIdentifier(v SubAccountIdentifier) OptionalSubAccountIdentifierType {
	return OptionalSubAccountIdentifierType{true, v}
}

// OptionalSubNetworkIdentifier creates an optional SubNetworkIdentifier value.
func OptionalSubNetworkIdentifier(v SubNetworkIdentifier) OptionalSubNetworkIdentifierType {
	return OptionalSubNetworkIdentifierType{true, v}
}

// OptionalSyncStatus creates an optional SyncStatus value.
func OptionalSyncStatus(v SyncStatus) OptionalSyncStatusType {
	return OptionalSyncStatusType{true, v}
}

// OptionalTransactionIdentifier creates an optional TransactionIdentifier value.
func OptionalTransactionIdentifier(v TransactionIdentifier) OptionalTransactionIdentifierType {
	return OptionalTransactionIdentifierType{true, v}
}

// AccountBalanceRequest type.
//
// An AccountBalanceRequest is utilized to make a balance request on the
// /account/balance endpoint. If the block_identifier is populated, a historical
// balance query should be performed.
type AccountBalanceRequest struct {
	AccountIdentifier AccountIdentifier
	BlockIdentifier   OptionalPartialBlockIdentifierType
	// In some cases, the caller may not want to retrieve all available balances
	// for an AccountIdentifier. If the currencies field is populated, only
	// balances for the specified currencies will be returned. If not populated,
	// all available balances will be returned.
	Currencies []Currency
}

// EncodeJSON encodes AccountBalanceRequest into JSON.
func (v AccountBalanceRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.AccountIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if v.BlockIdentifier.Set {
		b = append(b, '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.BlockIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if len(v.Currencies) > 0 {
		b = append(b, `"currencies":[`...)
		for i, elem := range v.Currencies {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two AccountBalanceRequest values are equal.
func (v AccountBalanceRequest) Equal(o AccountBalanceRequest) bool {
	return v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		v.BlockIdentifier.Value.Equal(o.BlockIdentifier.Value) &&
		v.BlockIdentifier.Set == o.BlockIdentifier.Set &&
		len(v.Currencies) == len(o.Currencies) &&
		currencySliceEqual(v.Currencies, o.Currencies)
}

// Reset resets AccountBalanceRequest so that it can be reused.
func (v *AccountBalanceRequest) Reset() {
	v.AccountIdentifier.Reset()
	v.BlockIdentifier.Value.Reset()
	v.BlockIdentifier.Set = false
	v.Currencies = v.Currencies[:0]
}

// AccountBalanceResponse type.
//
// An AccountBalanceResponse is returned on the /account/balance endpoint. If an
// account has a balance for each AccountIdentifier describing it (ex: an ERC-20
// token balance on a few smart contracts), an account balance request must be
// made with each AccountIdentifier.
//
// The `coins` field was removed and replaced by by `/account/coins` in
// `v1.4.7`.
type AccountBalanceResponse struct {
	// A single account may have a balance in multiple currencies.
	Balances        []Amount
	BlockIdentifier BlockIdentifier
	// Account-based blockchains that utilize a nonce or sequence number should
	// include that number in the metadata. This number could be unique to the
	// identifier or global across the account address.
	Metadata MapObject
}

// EncodeJSON encodes AccountBalanceResponse into JSON.
func (v AccountBalanceResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"balances":[`...)
	for i, elem := range v.Balances {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two AccountBalanceResponse values are equal.
func (v AccountBalanceResponse) Equal(o AccountBalanceResponse) bool {
	return len(v.Balances) == len(o.Balances) &&
		amountSliceEqual(v.Balances, o.Balances) &&
		v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		string(v.Metadata) == string(o.Metadata)
}

// Reset resets AccountBalanceResponse so that it can be reused.
func (v *AccountBalanceResponse) Reset() {
	v.Balances = v.Balances[:0]
	v.BlockIdentifier.Reset()
	v.Metadata = v.Metadata[:0]
}

// AccountCoinsRequest is utilized to make a request on the /account/coins
// endpoint.
type AccountCoinsRequest struct {
	AccountIdentifier AccountIdentifier
	// In some cases, the caller may not want to retrieve coins for all
	// currencies for an AccountIdentifier. If the currencies field is
	// populated, only coins for the specified currencies will be returned. If
	// not populated, all unspent coins will be returned.
	Currencies []Currency
	// Include state from the mempool when looking up an account's unspent
	// coins. Note, using this functionality breaks any guarantee of
	// idempotency.
	IncludeMempool bool
}

// EncodeJSON encodes AccountCoinsRequest into JSON.
func (v AccountCoinsRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.AccountIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if len(v.Currencies) > 0 {
		b = append(b, `"currencies":[`...)
		for i, elem := range v.Currencies {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b = append(b, '"', 'i', 'n', 'c', 'l', 'u', 'd', 'e', '_', 'm', 'e', 'm', 'p', 'o', 'o', 'l', '"', ':')
	b = json.AppendBool(b, v.IncludeMempool)
	return append(b, "}"...)
}

// Equal returns whether two AccountCoinsRequest values are equal.
func (v AccountCoinsRequest) Equal(o AccountCoinsRequest) bool {
	return v.AccountIdentifier.Equal(o.AccountIdentifier) &&
		len(v.Currencies) == len(o.Currencies) &&
		currencySliceEqual(v.Currencies, o.Currencies) &&
		v.IncludeMempool == o.IncludeMempool
}

// Reset resets AccountCoinsRequest so that it can be reused.
func (v *AccountCoinsRequest) Reset() {
	v.AccountIdentifier.Reset()
	v.Currencies = v.Currencies[:0]
	v.IncludeMempool = false
}

// AccountCoinsResponse is returned on the /account/coins endpoint and includes
// all unspent Coins owned by an AccountIdentifier.
type AccountCoinsResponse struct {
	BlockIdentifier BlockIdentifier
	// If a blockchain is UTXO-based, all unspent Coins owned by an
	// account_identifier should be returned alongside the balance. It is highly
	// recommended to populate this field so that users of the Rosetta API
	// implementation don't need to maintain their own indexer to track their
	// UTXOs.
	Coins []Coin
	// Account-based blockchains that utilize a nonce or sequence number should
	// include that number in the metadata. This number could be unique to the
	// identifier or global across the account address.
	Metadata MapObject
}

// EncodeJSON encodes AccountCoinsResponse into JSON.
func (v AccountCoinsResponse) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, `,"coins":[`...)
	for i, elem := range v.Coins {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two AccountCoinsResponse values are equal.
func (v AccountCoinsResponse) Equal(o AccountCoinsResponse) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		len(v.Coins) == len(o.Coins) &&
		coinSliceEqual(v.Coins, o.Coins) &&
		string(v.Metadata) == string(o.Metadata)
}

// Reset resets AccountCoinsResponse so that it can be reused.
func (v *AccountCoinsResponse) Reset() {
	v.BlockIdentifier.Reset()
	v.Coins = v.Coins[:0]
	v.Metadata = v.Metadata[:0]
}

// AccountIdentifier type.
//
// The account_identifier uniquely identifies an account within a network. All
// fields in the account_identifier are utilized to determine this uniqueness
// (including the metadata field, if populated).
type AccountIdentifier struct {
	// The address may be a cryptographic public key (or some encoding of it) or
	// a provided username.
	Address string
	// Blockchains that utilize a username model (where the address is not a
	// derivative of a cryptographic public key) should specify the public
	// key(s) owned by the address in metadata.
	Metadata   MapObject
	SubAccount OptionalSubAccountIdentifierType
}

// EncodeJSON encodes AccountIdentifier into JSON.
func (v AccountIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"address":`...)
	b = json.AppendString(b, v.Address)
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	if v.SubAccount.Set {
		b = append(b, `"sub_account":`...)
		b = v.SubAccount.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two AccountIdentifier values are equal.
func (v AccountIdentifier) Equal(o AccountIdentifier) bool {
	return v.Address == o.Address &&
		string(v.Metadata) == string(o.Metadata) &&
		v.SubAccount.Value.Equal(o.SubAccount.Value) &&
		v.SubAccount.Set == o.SubAccount.Set
}

// Reset resets AccountIdentifier so that it can be reused.
func (v *AccountIdentifier) Reset() {
	v.Address = ""
	v.Metadata = v.Metadata[:0]
	v.SubAccount.Value.Reset()
	v.SubAccount.Set = false
}

// Allow specifies supported Operation status, Operation types, and all possible
// error statuses. This Allow object is used by clients to validate the
// correctness of a Rosetta Server implementation. It is expected that these
// clients will error if they receive some response that contains any of the
// above information that is not specified here.
type Allow struct {
	// BalanceExemptions is an array of BalanceExemption indicating which
	// account balances could change without a corresponding Operation.
	//
	// BalanceExemptions should be used sparingly as they may introduce
	// significant complexity for integrators that attempt to reconcile all
	// account balance changes.
	//
	// If your implementation relies on any BalanceExemptions, you MUST
	// implement historical balance lookup (the ability to query an account
	// balance at any BlockIdentifier).
	BalanceExemptions []BalanceExemption
	// All methods that are supported by the /call endpoint. Communicating which
	// parameters should be provided to /call is the responsibility of the
	// implementer (this is en lieu of defining an entire type system and
	// requiring the implementer to define that in Allow).
	CallMethods []string
	// All Errors that this implementation could return. Any error that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	Errors []Error
	// Any Rosetta implementation that supports querying the balance of an
	// account at any height in the past should set this to true.
	HistoricalBalanceLookup bool
	// Any Rosetta implementation that can update an AccountIdentifier's unspent
	// coins based on the contents of the mempool should populate this field as
	// true. If false, requests to `/account/coins` that set `include_mempool`
	// as true will be automatically rejected.
	MempoolCoins bool
	// All Operation.Status this implementation supports. Any status that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	OperationStatuses []OperationStatus
	// All Operation.Type this implementation supports. Any type that is
	// returned during parsing that is not listed here will cause client
	// validation to error.
	OperationTypes []string
	// If populated, `timestamp_start_index` indicates the first block index
	// where block timestamps are considered valid (i.e. all blocks less than
	// `timestamp_start_index` could have invalid timestamps). This is useful
	// when the genesis block (or blocks) of a network have timestamp 0.
	//
	// If not populated, block timestamps are assumed to be valid for all
	// available blocks.
	TimestampStartIndex OptionalInt64Type
}

// EncodeJSON encodes Allow into JSON.
func (v Allow) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'b', 'a', 'l', 'a', 'n', 'c', 'e', '_', 'e', 'x', 'e', 'm', 'p', 't', 'i', 'o', 'n', 's', '"', ':', '[')
	for i, elem := range v.BalanceExemptions {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'c', 'a', 'l', 'l', '_', 'm', 'e', 't', 'h', 'o', 'd', 's', '"', ':', '[')
	for i, elem := range v.CallMethods {
		if i != 0 {
			b = append(b, ","...)
		}
		b = json.AppendString(b, elem)
	}
	b = append(b, `],"errors":[`...)
	for i, elem := range v.Errors {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'h', 'i', 's', 't', 'o', 'r', 'i', 'c', 'a', 'l', '_', 'b', 'a', 'l', 'a', 'n', 'c', 'e', '_', 'l', 'o', 'o', 'k', 'u', 'p', '"', ':')
	b = json.AppendBool(b, v.HistoricalBalanceLookup)
	b = append(b, ',', '"', 'm', 'e', 'm', 'p', 'o', 'o', 'l', '_', 'c', 'o', 'i', 'n', 's', '"', ':')
	b = json.AppendBool(b, v.MempoolCoins)
	b = append(b, ',', '"', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', '_', 's', 't', 'a', 't', 'u', 's', 'e', 's', '"', ':', '[')
	for i, elem := range v.OperationStatuses {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', '_', 't', 'y', 'p', 'e', 's', '"', ':', '[')
	for i, elem := range v.OperationTypes {
		if i != 0 {
			b = append(b, ","...)
		}
		b = json.AppendString(b, elem)
	}
	b = append(b, "],"...)
	if v.TimestampStartIndex.Set {
		b = append(b, '"', 't', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', '_', 's', 't', 'a', 'r', 't', '_', 'i', 'n', 'd', 'e', 'x', '"', ':')
		b = json.AppendInt(b, v.TimestampStartIndex.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two Allow values are equal.
func (v Allow) Equal(o Allow) bool {
	return len(v.BalanceExemptions) == len(o.BalanceExemptions) &&
		balanceExemptionSliceEqual(v.BalanceExemptions, o.BalanceExemptions) &&
		len(v.CallMethods) == len(o.CallMethods) &&
		stringSliceEqual(v.CallMethods, o.CallMethods) &&
		len(v.Errors) == len(o.Errors) &&
		errorSliceEqual(v.Errors, o.Errors) &&
		v.HistoricalBalanceLookup == o.HistoricalBalanceLookup &&
		v.MempoolCoins == o.MempoolCoins &&
		len(v.OperationStatuses) == len(o.OperationStatuses) &&
		operationStatusSliceEqual(v.OperationStatuses, o.OperationStatuses) &&
		len(v.OperationTypes) == len(o.OperationTypes) &&
		stringSliceEqual(v.OperationTypes, o.OperationTypes) &&
		v.TimestampStartIndex.Value == o.TimestampStartIndex.Value &&
		v.TimestampStartIndex.Set == o.TimestampStartIndex.Set
}

// Reset resets Allow so that it can be reused.
func (v *Allow) Reset() {
	v.BalanceExemptions = v.BalanceExemptions[:0]
	v.CallMethods = v.CallMethods[:0]
	v.Errors = v.Errors[:0]
	v.HistoricalBalanceLookup = false
	v.MempoolCoins = false
	v.OperationStatuses = v.OperationStatuses[:0]
	v.OperationTypes = v.OperationTypes[:0]
	v.TimestampStartIndex.Value = 0
	v.TimestampStartIndex.Set = false
}

// Amount is some Value of a Currency. It is considered invalid to specify a
// Value without a Currency.
type Amount struct {
	Currency Currency
	Metadata MapObject
	// Value of the transaction in atomic units represented as an
	// arbitrary-sized signed integer.
	//
	// For example, 1 BTC would be represented by a value of 100000000.
	Value string
}

// EncodeJSON encodes Amount into JSON.
func (v Amount) EncodeJSON(b []byte) []byte {
	b = append(b, `{"currency":`...)
	b = v.Currency.EncodeJSON(b)
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"value":`...)
	b = json.AppendString(b, v.Value)
	return append(b, "}"...)
}

// Equal returns whether two Amount values are equal.
func (v Amount) Equal(o Amount) bool {
	return v.Currency.Equal(o.Currency) &&
		string(v.Metadata) == string(o.Metadata) &&
		v.Value == o.Value
}

// Reset resets Amount so that it can be reused.
func (v *Amount) Reset() {
	v.Currency.Reset()
	v.Metadata = v.Metadata[:0]
	v.Value = ""
}

// BalanceExemption indicates that the balance for an exempt account could
// change without a corresponding Operation. This typically occurs with staking
// rewards, vesting balances, and Currencies with a dynamic supply.
//
// Currently, it is possible to exempt an account from strict reconciliation by
// SubAccountIdentifier.Address or by Currency. This means that any account with
// SubAccountIdentifier.Address would be exempt or any balance of a particular
// Currency would be exempt, respectively.
//
// BalanceExemptions should be used sparingly as they may introduce significant
// complexity for integrators that attempt to reconcile all account balance
// changes.
//
// If your implementation relies on any BalanceExemptions, you MUST implement
// historical balance lookup (the ability to query an account balance at any
// BlockIdentifier).
type BalanceExemption struct {
	Currency      OptionalCurrencyType
	ExemptionType OptionalExemptionTypeType
	// SubAccountAddress is the SubAccountIdentifier.Address that the
	// BalanceExemption applies to (regardless of the value of
	// SubAccountIdentifier.Metadata).
	SubAccountAddress OptionalStringType
}

// EncodeJSON encodes BalanceExemption into JSON.
func (v BalanceExemption) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.Currency.Set {
		b = append(b, `"currency":`...)
		b = v.Currency.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.ExemptionType.Set {
		b = append(b, '"', 'e', 'x', 'e', 'm', 'p', 't', 'i', 'o', 'n', '_', 't', 'y', 'p', 'e', '"', ':')
		b = json.AppendString(b, string(v.ExemptionType.Value))
		b = append(b, ","...)
	}
	if v.SubAccountAddress.Set {
		b = append(b, '"', 's', 'u', 'b', '_', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'a', 'd', 'd', 'r', 'e', 's', 's', '"', ':')
		b = json.AppendString(b, v.SubAccountAddress.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two BalanceExemption values are equal.
func (v BalanceExemption) Equal(o BalanceExemption) bool {
	return v.Currency.Value.Equal(o.Currency.Value) &&
		v.Currency.Set == o.Currency.Set &&
		v.ExemptionType.Value == o.ExemptionType.Value &&
		v.ExemptionType.Set == o.ExemptionType.Set &&
		v.SubAccountAddress.Value == o.SubAccountAddress.Value &&
		v.SubAccountAddress.Set == o.SubAccountAddress.Set
}

// Reset resets BalanceExemption so that it can be reused.
func (v *BalanceExemption) Reset() {
	v.Currency.Value.Reset()
	v.Currency.Set = false
	v.ExemptionType.Value = ""
	v.ExemptionType.Set = false
	v.SubAccountAddress.Value = ""
	v.SubAccountAddress.Set = false
}

// Block type.
//
// Blocks contain an array of Transactions that occurred at a particular
// BlockIdentifier.
//
// A hard requirement for blocks returned by Rosetta implementations is that
// they MUST be _inalterable_: once a client has requested and received a block
// identified by a specific BlockIndentifier, all future calls for that same
// BlockIdentifier must return the same block contents.
type Block struct {
	BlockIdentifier       BlockIdentifier
	Metadata              MapObject
	ParentBlockIdentifier BlockIdentifier
	Timestamp             Timestamp
	Transactions          []Transaction
}

// EncodeJSON encodes Block into JSON.
func (v Block) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, '"', 'p', 'a', 'r', 'e', 'n', 't', '_', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.ParentBlockIdentifier.EncodeJSON(b)
	b = append(b, `,"timestamp":`...)
	b = json.AppendInt(b, int64(v.Timestamp))
	b = append(b, ',', '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', 's', '"', ':', '[')
	for i, elem := range v.Transactions {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	return append(b, "]}"...)
}

// Equal returns whether two Block values are equal.
func (v Block) Equal(o Block) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		string(v.Metadata) == string(o.Metadata) &&
		v.ParentBlockIdentifier.Equal(o.ParentBlockIdentifier) &&
		v.Timestamp == o.Timestamp &&
		len(v.Transactions) == len(o.Transactions) &&
		transactionSliceEqual(v.Transactions, o.Transactions)
}

// Reset resets Block so that it can be reused.
func (v *Block) Reset() {
	v.BlockIdentifier.Reset()
	v.Metadata = v.Metadata[:0]
	v.ParentBlockIdentifier.Reset()
	v.Timestamp = 0
	v.Transactions = v.Transactions[:0]
}

// BlockEvent represents the addition or removal of a BlockIdentifier from
// storage. Streaming BlockEvents allows lightweight clients to update their own
// state without needing to implement their own syncing logic.
type BlockEvent struct {
	BlockIdentifier BlockIdentifier
	// sequence is the unique identifier of a BlockEvent within the context of a
	// NetworkIdentifier.
	Sequence int64
	Type     BlockEventType
}

// EncodeJSON encodes BlockEvent into JSON.
func (v BlockEvent) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, `,"sequence":`...)
	b = json.AppendInt(b, v.Sequence)
	b = append(b, `,"type":`...)
	b = json.AppendString(b, string(v.Type))
	return append(b, "}"...)
}

// Equal returns whether two BlockEvent values are equal.
func (v BlockEvent) Equal(o BlockEvent) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.Sequence == o.Sequence &&
		v.Type == o.Type
}

// Reset resets BlockEvent so that it can be reused.
func (v *BlockEvent) Reset() {
	v.BlockIdentifier.Reset()
	v.Sequence = 0
	v.Type = ""
}

// BlockEventType determines if a BlockEvent represents the addition or removal
// of a block.
type BlockEventType string

// Validate the BlockEventType value.
func (v BlockEventType) Validate() error {
	if !(v == "block_added" || v == "block_removed") {
		return fmt.Errorf("api: invalid BlockEventType value: %q", v)
	}
	return nil
}

// BlockIdentifier type.
//
// The block_identifier uniquely identifies a block in a particular network.
type BlockIdentifier struct {
	Hash string
	// This is also known as the block height.
	Index int64
}

// EncodeJSON encodes BlockIdentifier into JSON.
func (v BlockIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"hash":`...)
	b = json.AppendString(b, v.Hash)
	b = append(b, `,"index":`...)
	b = json.AppendInt(b, v.Index)
	return append(b, "}"...)
}

// Equal returns whether two BlockIdentifier values are equal.
func (v BlockIdentifier) Equal(o BlockIdentifier) bool {
	return v.Hash == o.Hash &&
		v.Index == o.Index
}

// Reset resets BlockIdentifier so that it can be reused.
func (v *BlockIdentifier) Reset() {
	v.Hash = ""
	v.Index = 0
}

// BlockRequest type.
//
// A BlockRequest is utilized to make a block request on the /block endpoint.
type BlockRequest struct {
	BlockIdentifier PartialBlockIdentifier
}

// EncodeJSON encodes BlockRequest into JSON.
func (v BlockRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two BlockRequest values are equal.
func (v BlockRequest) Equal(o BlockRequest) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier)
}

// Reset resets BlockRequest so that it can be reused.
func (v *BlockRequest) Reset() {
	v.BlockIdentifier.Reset()
}

// BlockResponse type.
//
// A BlockResponse includes a fully-populated block or a partially-populated
// block with a list of other transactions to fetch (other_transactions).
//
// As a result of the consensus algorithm of some blockchains, blocks can be
// omitted (i.e. certain block indices can be skipped). If a query for one of
// these omitted indices is made, the response should not include a `Block`
// object.
//
// It is VERY important to note that blocks MUST still form a canonical,
// connected chain of blocks where each block has a unique index. In other
// words, the `PartialBlockIdentifier` of a block after an omitted block should
// reference the last non-omitted block.
type BlockResponse struct {
	Block OptionalBlockType
	// Some blockchains may require additional transactions to be fetched that
	// weren't returned in the block response (ex: block only returns
	// transaction hashes). For blockchains with a lot of transactions in each
	// block, this can be very useful as consumers can concurrently fetch all
	// transactions returned.
	OtherTransactions []TransactionIdentifier
}

// EncodeJSON encodes BlockResponse into JSON.
func (v BlockResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.Block.Set {
		b = append(b, `"block":`...)
		b = v.Block.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if len(v.OtherTransactions) > 0 {
		b = append(b, '"', 'o', 't', 'h', 'e', 'r', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', 's', '"', ':', '[')
		for i, elem := range v.OtherTransactions {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two BlockResponse values are equal.
func (v BlockResponse) Equal(o BlockResponse) bool {
	return v.Block.Value.Equal(o.Block.Value) &&
		v.Block.Set == o.Block.Set &&
		len(v.OtherTransactions) == len(o.OtherTransactions) &&
		transactionIdentifierSliceEqual(v.OtherTransactions, o.OtherTransactions)
}

// Reset resets BlockResponse so that it can be reused.
func (v *BlockResponse) Reset() {
	v.Block.Value.Reset()
	v.Block.Set = false
	v.OtherTransactions = v.OtherTransactions[:0]
}

// BlockTransaction contains a populated Transaction and the BlockIdentifier
// that contains it.
type BlockTransaction struct {
	BlockIdentifier BlockIdentifier
	Transaction     Transaction
}

// EncodeJSON encodes BlockTransaction into JSON.
func (v BlockTransaction) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, `,"transaction":`...)
	b = v.Transaction.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two BlockTransaction values are equal.
func (v BlockTransaction) Equal(o BlockTransaction) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.Transaction.Equal(o.Transaction)
}

// Reset resets BlockTransaction so that it can be reused.
func (v *BlockTransaction) Reset() {
	v.BlockIdentifier.Reset()
	v.Transaction.Reset()
}

// BlockTransactionRequest type.
//
// A BlockTransactionRequest is used to fetch a Transaction included in a block
// that is not returned in a BlockResponse.
type BlockTransactionRequest struct {
	BlockIdentifier       BlockIdentifier
	TransactionIdentifier TransactionIdentifier
}

// EncodeJSON encodes BlockTransactionRequest into JSON.
func (v BlockTransactionRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.BlockIdentifier.EncodeJSON(b)
	b = append(b, ',', '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.TransactionIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two BlockTransactionRequest values are equal.
func (v BlockTransactionRequest) Equal(o BlockTransactionRequest) bool {
	return v.BlockIdentifier.Equal(o.BlockIdentifier) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets BlockTransactionRequest so that it can be reused.
func (v *BlockTransactionRequest) Reset() {
	v.BlockIdentifier.Reset()
	v.TransactionIdentifier.Reset()
}

// BlockTransactionResponse type.
//
// A BlockTransactionResponse contains information about a block transaction.
type BlockTransactionResponse struct {
	Transaction Transaction
}

// EncodeJSON encodes BlockTransactionResponse into JSON.
func (v BlockTransactionResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"transaction":`...)
	b = v.Transaction.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two BlockTransactionResponse values are equal.
func (v BlockTransactionResponse) Equal(o BlockTransactionResponse) bool {
	return v.Transaction.Equal(o.Transaction)
}

// Reset resets BlockTransactionResponse so that it can be reused.
func (v *BlockTransactionResponse) Reset() {
	v.Transaction.Reset()
}

// CallRequest is the input to the `/call` endpoint.
type CallRequest struct {
	// Method is some network-specific procedure call. This method could map to
	// a network-specific RPC endpoint, a method in an SDK generated from a
	// smart contract, or some hybrid of the two.
	//
	// The implementation must define all available methods in the Allow object.
	// However, it is up to the caller to determine which parameters to provide
	// when invoking `/call`.
	Method string
	// Parameters is some network-specific argument for a method. It is up to
	// the caller to determine which parameters to provide when invoking
	// `/call`.
	Parameters MapObject
}

// EncodeJSON encodes CallRequest into JSON.
func (v CallRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, `"method":`...)
	b = json.AppendString(b, v.Method)
	b = append(b, `,"parameters":`...)
	b = appendMapObject(b, v.Parameters)
	return append(b, "}"...)
}

// Equal returns whether two CallRequest values are equal.
func (v CallRequest) Equal(o CallRequest) bool {
	return v.Method == o.Method &&
		string(v.Parameters) == string(o.Parameters)
}

// Reset resets CallRequest so that it can be reused.
func (v *CallRequest) Reset() {
	v.Method = ""
	v.Parameters = v.Parameters[:0]
}

// CallResponse contains the result of a `/call` invocation.
type CallResponse struct {
	// Idempotent indicates that if `/call` is invoked with the same CallRequest
	// again, at any point in time, it will return the same CallResponse.
	//
	// Integrators may cache the CallResponse if this is set to true to avoid
	// making unnecessary calls to the Rosetta implementation. For this reason,
	// implementers should be very conservative about returning true here or
	// they could cause issues for the caller.
	Idempotent bool
	// Result contains the result of the `/call` invocation. This result will
	// not be inspected or interpreted by Rosetta tooling and is left to the
	// caller to decode.
	Result MapObject
}

// EncodeJSON encodes CallResponse into JSON.
func (v CallResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"idempotent":`...)
	b = json.AppendBool(b, v.Idempotent)
	b = append(b, `,"result":`...)
	b = appendMapObject(b, v.Result)
	return append(b, "}"...)
}

// Equal returns whether two CallResponse values are equal.
func (v CallResponse) Equal(o CallResponse) bool {
	return v.Idempotent == o.Idempotent &&
		string(v.Result) == string(o.Result)
}

// Reset resets CallResponse so that it can be reused.
func (v *CallResponse) Reset() {
	v.Idempotent = false
	v.Result = v.Result[:0]
}

// Coin contains its unique identifier and the amount it represents.
type Coin struct {
	Amount         Amount
	CoinIdentifier CoinIdentifier
}

// EncodeJSON encodes Coin into JSON.
func (v Coin) EncodeJSON(b []byte) []byte {
	b = append(b, `{"amount":`...)
	b = v.Amount.EncodeJSON(b)
	b = append(b, ',', '"', 'c', 'o', 'i', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.CoinIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two Coin values are equal.
func (v Coin) Equal(o Coin) bool {
	return v.Amount.Equal(o.Amount) &&
		v.CoinIdentifier.Equal(o.CoinIdentifier)
}

// Reset resets Coin so that it can be reused.
func (v *Coin) Reset() {
	v.Amount.Reset()
	v.CoinIdentifier.Reset()
}

// CoinAction type.
//
// CoinActions are different state changes that a Coin can undergo. When a Coin
// is created, it is coin_created. When a Coin is spent, it is coin_spent. It is
// assumed that a single Coin cannot be created or spent more than once.
type CoinAction string

// Validate the CoinAction value.
func (v CoinAction) Validate() error {
	if !(v == "coin_created" || v == "coin_spent") {
		return fmt.Errorf("api: invalid CoinAction value: %q", v)
	}
	return nil
}

// CoinChange is used to represent a change in state of a some coin identified
// by a coin_identifier. This object is part of the Operation model and must be
// populated for UTXO-based blockchains.
//
// Coincidentally, this abstraction of UTXOs allows for supporting both
// account-based transfers and UTXO-based transfers on the same blockchain (when
// a transfer is account-based, don't populate this model).
type CoinChange struct {
	CoinAction     CoinAction
	CoinIdentifier CoinIdentifier
}

// EncodeJSON encodes CoinChange into JSON.
func (v CoinChange) EncodeJSON(b []byte) []byte {
	b = append(b, `{"coin_action":`...)
	b = json.AppendString(b, string(v.CoinAction))
	b = append(b, ',', '"', 'c', 'o', 'i', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.CoinIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two CoinChange values are equal.
func (v CoinChange) Equal(o CoinChange) bool {
	return v.CoinAction == o.CoinAction &&
		v.CoinIdentifier.Equal(o.CoinIdentifier)
}

// Reset resets CoinChange so that it can be reused.
func (v *CoinChange) Reset() {
	v.CoinAction = ""
	v.CoinIdentifier.Reset()
}

// CoinIdentifier uniquely identifies a Coin.
type CoinIdentifier struct {
	// Identifier should be populated with a globally unique identifier of a
	// Coin. In Bitcoin, this identifier would be transaction_hash:index.
	Identifier string
}

// EncodeJSON encodes CoinIdentifier into JSON.
func (v CoinIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"identifier":`...)
	b = json.AppendString(b, v.Identifier)
	return append(b, "}"...)
}

// Equal returns whether two CoinIdentifier values are equal.
func (v CoinIdentifier) Equal(o CoinIdentifier) bool {
	return v.Identifier == o.Identifier
}

// Reset resets CoinIdentifier so that it can be reused.
func (v *CoinIdentifier) Reset() {
	v.Identifier = ""
}

// ConstructionCombineRequest is the input to the `/construction/combine`
// endpoint. It contains the unsigned transaction blob returned by
// `/construction/payloads` and all required signatures to create a network
// transaction.
type ConstructionCombineRequest struct {
	Signatures          []Signature
	UnsignedTransaction string
}

// EncodeJSON encodes ConstructionCombineRequest into JSON.
func (v ConstructionCombineRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, `"signatures":[`...)
	for i, elem := range v.Signatures {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'u', 'n', 's', 'i', 'g', 'n', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.UnsignedTransaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionCombineRequest values are equal.
func (v ConstructionCombineRequest) Equal(o ConstructionCombineRequest) bool {
	return len(v.Signatures) == len(o.Signatures) &&
		signatureSliceEqual(v.Signatures, o.Signatures) &&
		v.UnsignedTransaction == o.UnsignedTransaction
}

// Reset resets ConstructionCombineRequest so that it can be reused.
func (v *ConstructionCombineRequest) Reset() {
	v.Signatures = v.Signatures[:0]
	v.UnsignedTransaction = ""
}

// ConstructionCombineResponse is returned by `/construction/combine`. The
// network payload will be sent directly to the `construction/submit` endpoint.
type ConstructionCombineResponse struct {
	SignedTransaction string
}

// EncodeJSON encodes ConstructionCombineResponse into JSON.
func (v ConstructionCombineResponse) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 's', 'i', 'g', 'n', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.SignedTransaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionCombineResponse values are equal.
func (v ConstructionCombineResponse) Equal(o ConstructionCombineResponse) bool {
	return v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionCombineResponse so that it can be reused.
func (v *ConstructionCombineResponse) Reset() {
	v.SignedTransaction = ""
}

// ConstructionDeriveRequest is passed to the `/construction/derive` endpoint.
// Network is provided in the request because some blockchains have different
// address formats for different networks. Metadata is provided in the request
// because some blockchains allow for multiple address types (i.e. different
// address for validators vs normal accounts).
type ConstructionDeriveRequest struct {
	Metadata  MapObject
	PublicKey PublicKey
}

// EncodeJSON encodes ConstructionDeriveRequest into JSON.
func (v ConstructionDeriveRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"public_key":`...)
	b = v.PublicKey.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionDeriveRequest values are equal.
func (v ConstructionDeriveRequest) Equal(o ConstructionDeriveRequest) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.PublicKey.Equal(o.PublicKey)
}

// Reset resets ConstructionDeriveRequest so that it can be reused.
func (v *ConstructionDeriveRequest) Reset() {
	v.Metadata = v.Metadata[:0]
	v.PublicKey.Reset()
}

// ConstructionDeriveResponse is returned by the `/construction/derive`
// endpoint.
type ConstructionDeriveResponse struct {
	AccountIdentifier OptionalAccountIdentifierType
	// [DEPRECATED by `account_identifier` in `v1.4.4`] Address in
	// network-specific format.
	Address  OptionalStringType
	Metadata MapObject
}

// EncodeJSON encodes ConstructionDeriveResponse into JSON.
func (v ConstructionDeriveResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.AccountIdentifier.Set {
		b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.AccountIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Address.Set {
		b = append(b, `"address":`...)
		b = json.AppendString(b, v.Address.Value)
		b = append(b, ","...)
	}
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionDeriveResponse values are equal.
func (v ConstructionDeriveResponse) Equal(o ConstructionDeriveResponse) bool {
	return v.AccountIdentifier.Value.Equal(o.AccountIdentifier.Value) &&
		v.AccountIdentifier.Set == o.AccountIdentifier.Set &&
		v.Address.Value == o.Address.Value &&
		v.Address.Set == o.Address.Set &&
		string(v.Metadata) == string(o.Metadata)
}

// Reset resets ConstructionDeriveResponse so that it can be reused.
func (v *ConstructionDeriveResponse) Reset() {
	v.AccountIdentifier.Value.Reset()
	v.AccountIdentifier.Set = false
	v.Address.Value = ""
	v.Address.Set = false
	v.Metadata = v.Metadata[:0]
}

// ConstructionHashRequest is the input to the `/construction/hash` endpoint.
type ConstructionHashRequest struct {
	SignedTransaction string
}

// EncodeJSON encodes ConstructionHashRequest into JSON.
func (v ConstructionHashRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 's', 'i', 'g', 'n', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.SignedTransaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionHashRequest values are equal.
func (v ConstructionHashRequest) Equal(o ConstructionHashRequest) bool {
	return v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionHashRequest so that it can be reused.
func (v *ConstructionHashRequest) Reset() {
	v.SignedTransaction = ""
}

// ConstructionMetadataRequest type.
//
// A ConstructionMetadataRequest is utilized to get information required to
// construct a transaction.
//
// The Options object used to specify which metadata to return is left purposely
// unstructured to allow flexibility for implementers. Options is not required
// in the case that there is network-wide metadata of interest.
//
// Optionally, the request can also include an array of PublicKeys associated
// with the AccountIdentifiers returned in ConstructionPreprocessResponse.
type ConstructionMetadataRequest struct {
	// Some blockchains require different metadata for different types of
	// transaction construction (ex: delegation versus a transfer). Instead of
	// requiring a blockchain node to return all possible types of metadata for
	// construction (which may require multiple node fetches), the client can
	// populate an options object to limit the metadata returned to only the
	// subset required.
	Options    MapObject
	PublicKeys []PublicKey
}

// EncodeJSON encodes ConstructionMetadataRequest into JSON.
func (v ConstructionMetadataRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if len(v.Options) > 0 {
		b = append(b, `"options":`...)
		b = append(b, v.Options...)
		b = append(b, ","...)
	}
	if len(v.PublicKeys) > 0 {
		b = append(b, `"public_keys":[`...)
		for i, elem := range v.PublicKeys {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionMetadataRequest values are equal.
func (v ConstructionMetadataRequest) Equal(o ConstructionMetadataRequest) bool {
	return string(v.Options) == string(o.Options) &&
		len(v.PublicKeys) == len(o.PublicKeys) &&
		publicKeySliceEqual(v.PublicKeys, o.PublicKeys)
}

// Reset resets ConstructionMetadataRequest so that it can be reused.
func (v *ConstructionMetadataRequest) Reset() {
	v.Options = v.Options[:0]
	v.PublicKeys = v.PublicKeys[:0]
}

// ConstructionMetadataResponse type.
//
// The ConstructionMetadataResponse returns network-specific metadata used for
// transaction construction.
//
// Optionally, the implementer can return the suggested fee associated with the
// transaction being constructed. The caller may use this info to adjust the
// intent of the transaction or to create a transaction with a different account
// that can pay the suggested fee. Suggested fee is an array in case fee payment
// must occur in multiple currencies.
type ConstructionMetadataResponse struct {
	Metadata     MapObject
	SuggestedFee []Amount
}

// EncodeJSON encodes ConstructionMetadataResponse into JSON.
func (v ConstructionMetadataResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"metadata":`...)
	b = appendMapObject(b, v.Metadata)
	b = append(b, ","...)
	if len(v.SuggestedFee) > 0 {
		b = append(b, '"', 's', 'u', 'g', 'g', 'e', 's', 't', 'e', 'd', '_', 'f', 'e', 'e', '"', ':', '[')
		for i, elem := range v.SuggestedFee {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionMetadataResponse values are equal.
func (v ConstructionMetadataResponse) Equal(o ConstructionMetadataResponse) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		len(v.SuggestedFee) == len(o.SuggestedFee) &&
		amountSliceEqual(v.SuggestedFee, o.SuggestedFee)
}

// Reset resets ConstructionMetadataResponse so that it can be reused.
func (v *ConstructionMetadataResponse) Reset() {
	v.Metadata = v.Metadata[:0]
	v.SuggestedFee = v.SuggestedFee[:0]
}

// ConstructionParseRequest is the input to the `/construction/parse` endpoint.
// It allows the caller to parse either an unsigned or signed transaction.
type ConstructionParseRequest struct {
	// Signed is a boolean indicating whether the transaction is signed.
	Signed bool
	// This must be either the unsigned transaction blob returned by
	// `/construction/payloads` or the signed transaction blob returned by
	// `/construction/combine`.
	Transaction string
}

// EncodeJSON encodes ConstructionParseRequest into JSON.
func (v ConstructionParseRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, `"signed":`...)
	b = json.AppendBool(b, v.Signed)
	b = append(b, `,"transaction":`...)
	b = json.AppendString(b, v.Transaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionParseRequest values are equal.
func (v ConstructionParseRequest) Equal(o ConstructionParseRequest) bool {
	return v.Signed == o.Signed &&
		v.Transaction == o.Transaction
}

// Reset resets ConstructionParseRequest so that it can be reused.
func (v *ConstructionParseRequest) Reset() {
	v.Signed = false
	v.Transaction = ""
}

// ConstructionParseResponse contains an array of operations that occur in a
// transaction blob. This should match the array of operations provided to
// `/construction/preprocess` and `/construction/payloads`.
type ConstructionParseResponse struct {
	AccountIdentifierSigners []AccountIdentifier
	Metadata                 MapObject
	Operations               []Operation
	// [DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers
	// (addresses) of a particular transaction. If the transaction is unsigned,
	// it should be empty.
	Signers []string
}

// EncodeJSON encodes ConstructionParseResponse into JSON.
func (v ConstructionParseResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.AccountIdentifierSigners) > 0 {
		b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '_', 's', 'i', 'g', 'n', 'e', 'r', 's', '"', ':', '[')
		for i, elem := range v.AccountIdentifierSigners {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"operations":[`...)
	for i, elem := range v.Operations {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if len(v.Signers) > 0 {
		b = append(b, `"signers":[`...)
		for i, elem := range v.Signers {
			if i != 0 {
				b = append(b, ","...)
			}
			b = json.AppendString(b, elem)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionParseResponse values are equal.
func (v ConstructionParseResponse) Equal(o ConstructionParseResponse) bool {
	return len(v.AccountIdentifierSigners) == len(o.AccountIdentifierSigners) &&
		accountIdentifierSliceEqual(v.AccountIdentifierSigners, o.AccountIdentifierSigners) &&
		string(v.Metadata) == string(o.Metadata) &&
		len(v.Operations) == len(o.Operations) &&
		operationSliceEqual(v.Operations, o.Operations) &&
		len(v.Signers) == len(o.Signers) &&
		stringSliceEqual(v.Signers, o.Signers)
}

// Reset resets ConstructionParseResponse so that it can be reused.
func (v *ConstructionParseResponse) Reset() {
	v.AccountIdentifierSigners = v.AccountIdentifierSigners[:0]
	v.Metadata = v.Metadata[:0]
	v.Operations = v.Operations[:0]
	v.Signers = v.Signers[:0]
}

// ConstructionPayloadsRequest is the request to `/construction/payloads`. It
// contains the network, a slice of operations, and arbitrary metadata that was
// returned by the call to `/construction/metadata`.
//
// Optionally, the request can also include an array of PublicKeys associated
// with the AccountIdentifiers returned in ConstructionPreprocessResponse.
type ConstructionPayloadsRequest struct {
	Metadata   MapObject
	Operations []Operation
	PublicKeys []PublicKey
}

// EncodeJSON encodes ConstructionPayloadsRequest into JSON.
func (v ConstructionPayloadsRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"operations":[`...)
	for i, elem := range v.Operations {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if len(v.PublicKeys) > 0 {
		b = append(b, `"public_keys":[`...)
		for i, elem := range v.PublicKeys {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionPayloadsRequest values are equal.
func (v ConstructionPayloadsRequest) Equal(o ConstructionPayloadsRequest) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		len(v.Operations) == len(o.Operations) &&
		operationSliceEqual(v.Operations, o.Operations) &&
		len(v.PublicKeys) == len(o.PublicKeys) &&
		publicKeySliceEqual(v.PublicKeys, o.PublicKeys)
}

// Reset resets ConstructionPayloadsRequest so that it can be reused.
func (v *ConstructionPayloadsRequest) Reset() {
	v.Metadata = v.Metadata[:0]
	v.Operations = v.Operations[:0]
	v.PublicKeys = v.PublicKeys[:0]
}

// ConstructionPayloadsResponse type.
//
// ConstructionTransactionResponse is returned by `/construction/payloads`. It
// contains an unsigned transaction blob (that is usually needed to construct
// the a network transaction from a collection of signatures) and an array of
// payloads that must be signed by the caller.
type ConstructionPayloadsResponse struct {
	Payloads            []SigningPayload
	UnsignedTransaction string
}

// EncodeJSON encodes ConstructionPayloadsResponse into JSON.
func (v ConstructionPayloadsResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"payloads":[`...)
	for i, elem := range v.Payloads {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'u', 'n', 's', 'i', 'g', 'n', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.UnsignedTransaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionPayloadsResponse values are equal.
func (v ConstructionPayloadsResponse) Equal(o ConstructionPayloadsResponse) bool {
	return len(v.Payloads) == len(o.Payloads) &&
		signingPayloadSliceEqual(v.Payloads, o.Payloads) &&
		v.UnsignedTransaction == o.UnsignedTransaction
}

// Reset resets ConstructionPayloadsResponse so that it can be reused.
func (v *ConstructionPayloadsResponse) Reset() {
	v.Payloads = v.Payloads[:0]
	v.UnsignedTransaction = ""
}

// ConstructionPreprocessRequest is passed to the `/construction/preprocess`
// endpoint so that a Rosetta implementation can determine which metadata it
// needs to request for construction.
//
// Metadata provided in this object should NEVER be a product of live data (i.e.
// the caller must follow some network-specific data fetching strategy outside
// of the Construction API to populate required Metadata). If live data is
// required for construction, it MUST be fetched in the call to
// `/construction/metadata`.
//
// The caller can provide a max fee they are willing to pay for a transaction.
// This is an array in the case fees must be paid in multiple currencies.
//
// The caller can also provide a suggested fee multiplier to indicate that the
// suggested fee should be scaled. This may be used to set higher fees for
// urgent transactions or to pay lower fees when there is less urgency. It is
// assumed that providing a very low multiplier (like 0.0001) will never lead to
// a transaction being created with a fee less than the minimum network fee (if
// applicable).
//
// In the case that the caller provides both a max fee and a suggested fee
// multiplier, the max fee will set an upper bound on the suggested fee
// (regardless of the multiplier provided).
type ConstructionPreprocessRequest struct {
	MaxFee                 []Amount
	Metadata               MapObject
	Operations             []Operation
	SuggestedFeeMultiplier OptionalFloat64Type
}

// EncodeJSON encodes ConstructionPreprocessRequest into JSON.
func (v ConstructionPreprocessRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if len(v.MaxFee) > 0 {
		b = append(b, `"max_fee":[`...)
		for i, elem := range v.MaxFee {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"operations":[`...)
	for i, elem := range v.Operations {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if v.SuggestedFeeMultiplier.Set {
		b = append(b, '"', 's', 'u', 'g', 'g', 'e', 's', 't', 'e', 'd', '_', 'f', 'e', 'e', '_', 'm', 'u', 'l', 't', 'i', 'p', 'l', 'i', 'e', 'r', '"', ':')
		b = json.AppendFloat(b, v.SuggestedFeeMultiplier.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionPreprocessRequest values are equal.
func (v ConstructionPreprocessRequest) Equal(o ConstructionPreprocessRequest) bool {
	return len(v.MaxFee) == len(o.MaxFee) &&
		amountSliceEqual(v.MaxFee, o.MaxFee) &&
		string(v.Metadata) == string(o.Metadata) &&
		len(v.Operations) == len(o.Operations) &&
		operationSliceEqual(v.Operations, o.Operations) &&
		v.SuggestedFeeMultiplier.Value == o.SuggestedFeeMultiplier.Value &&
		v.SuggestedFeeMultiplier.Set == o.SuggestedFeeMultiplier.Set
}

// Reset resets ConstructionPreprocessRequest so that it can be reused.
func (v *ConstructionPreprocessRequest) Reset() {
	v.MaxFee = v.MaxFee[:0]
	v.Metadata = v.Metadata[:0]
	v.Operations = v.Operations[:0]
	v.SuggestedFeeMultiplier.Value = 0
	v.SuggestedFeeMultiplier.Set = false
}

// ConstructionPreprocessResponse contains `options` that will be sent
// unmodified to `/construction/metadata`. If it is not necessary to make a
// request to `/construction/metadata`, `options` should be omitted.
//
// Some blockchains require the PublicKey of particular AccountIdentifiers to
// construct a valid transaction. To fetch these PublicKeys, populate
// `required_public_keys` with the AccountIdentifiers associated with the
// desired PublicKeys. If it is not necessary to retrieve any PublicKeys for
// construction, `required_public_keys` should be omitted.
type ConstructionPreprocessResponse struct {
	// The options that will be sent directly to `/construction/metadata` by the
	// caller.
	Options            MapObject
	RequiredPublicKeys []AccountIdentifier
}

// EncodeJSON encodes ConstructionPreprocessResponse into JSON.
func (v ConstructionPreprocessResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Options) > 0 {
		b = append(b, `"options":`...)
		b = append(b, v.Options...)
		b = append(b, ","...)
	}
	if len(v.RequiredPublicKeys) > 0 {
		b = append(b, '"', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', '_', 'p', 'u', 'b', 'l', 'i', 'c', '_', 'k', 'e', 'y', 's', '"', ':', '[')
		for i, elem := range v.RequiredPublicKeys {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two ConstructionPreprocessResponse values are equal.
func (v ConstructionPreprocessResponse) Equal(o ConstructionPreprocessResponse) bool {
	return string(v.Options) == string(o.Options) &&
		len(v.RequiredPublicKeys) == len(o.RequiredPublicKeys) &&
		accountIdentifierSliceEqual(v.RequiredPublicKeys, o.RequiredPublicKeys)
}

// Reset resets ConstructionPreprocessResponse so that it can be reused.
func (v *ConstructionPreprocessResponse) Reset() {
	v.Options = v.Options[:0]
	v.RequiredPublicKeys = v.RequiredPublicKeys[:0]
}

// ConstructionSubmitRequest type.
//
// The transaction submission request includes a signed transaction.
type ConstructionSubmitRequest struct {
	SignedTransaction string
}

// EncodeJSON encodes ConstructionSubmitRequest into JSON.
func (v ConstructionSubmitRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 's', 'i', 'g', 'n', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.SignedTransaction)
	return append(b, "}"...)
}

// Equal returns whether two ConstructionSubmitRequest values are equal.
func (v ConstructionSubmitRequest) Equal(o ConstructionSubmitRequest) bool {
	return v.SignedTransaction == o.SignedTransaction
}

// Reset resets ConstructionSubmitRequest so that it can be reused.
func (v *ConstructionSubmitRequest) Reset() {
	v.SignedTransaction = ""
}

// Currency is composed of a canonical Symbol and Decimals. This Decimals value
// is used to convert an Amount.Value from atomic units (Satoshis) to standard
// units (Bitcoins).
type Currency struct {
	// Number of decimal places in the standard unit representation of the
	// amount.
	//
	// For example, BTC has 8 decimals. Note that it is not possible to
	// represent the value of some currency in atomic units that is not base 10.
	Decimals int32
	// Any additional information related to the currency itself.
	//
	// For example, it would be useful to populate this object with the contract
	// address of an ERC-20 token.
	Metadata MapObject
	// Canonical symbol associated with a currency.
	Symbol string
}

// EncodeJSON encodes Currency into JSON.
func (v Currency) EncodeJSON(b []byte) []byte {
	b = append(b, `{"decimals":`...)
	b = json.AppendInt(b, int64(v.Decimals))
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"symbol":`...)
	b = json.AppendString(b, v.Symbol)
	return append(b, "}"...)
}

// Equal returns whether two Currency values are equal.
func (v Currency) Equal(o Currency) bool {
	return v.Decimals == o.Decimals &&
		string(v.Metadata) == string(o.Metadata) &&
		v.Symbol == o.Symbol
}

// Reset resets Currency so that it can be reused.
func (v *Currency) Reset() {
	v.Decimals = 0
	v.Metadata = v.Metadata[:0]
	v.Symbol = ""
}

// CurveType is the type of cryptographic curve associated with a PublicKey.
//
// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
type CurveType string

// Validate the CurveType value.
func (v CurveType) Validate() error {
	if !(v == "edwards25519" || v == "secp256k1" || v == "secp256r1" || v == "tweedle") {
		return fmt.Errorf("api: invalid CurveType value: %q", v)
	}
	return nil
}

// Direction type.
//
// Used by RelatedTransaction to indicate the direction of the relation (i.e.
// cross-shard/cross-network sends may reference `backward` to an earlier
// transaction and async execution may reference `forward`). Can be used to
// indicate if a transaction relation is from child to parent or the reverse.
type Direction string

// Validate the Direction value.
func (v Direction) Validate() error {
	if !(v == "backward" || v == "forward") {
		return fmt.Errorf("api: invalid Direction value: %q", v)
	}
	return nil
}

// Error type.
//
// Instead of utilizing HTTP status codes to describe node errors (which often
// do not have a good analog), rich errors are returned using this object.
//
// Both the code and message fields can be individually used to correctly
// identify an error. Implementations MUST use unique values for both fields.
type Error struct {
	// Code is a network-specific error code. If desired, this code can be
	// equivalent to an HTTP status code.
	Code int32
	// Description allows the implementer to optionally provide additional
	// information about an error. In many cases, the content of this field will
	// be a copy-and-paste from existing developer documentation.
	//
	// Description can ONLY be populated with generic information about a
	// particular type of error. It MUST NOT be populated with information about
	// a particular instantiation of an error (use `details` for this).
	//
	// Whereas the content of Error.Message should stay stable across releases,
	// the content of Error.Description will likely change across releases (as
	// implementers improve error documentation). For this reason, the content
	// in this field is not part of any type assertion (unlike Error.Message).
	Description OptionalStringType
	// Often times it is useful to return context specific to the request that
	// caused the error (i.e. a sample of the stack trace or impacted account)
	// in addition to the standard error message.
	Details MapObject
	// Message is a network-specific error message.
	//
	// The message MUST NOT change for a given code. In particular, this means
	// that any contextual information should be included in the details field.
	Message string
	// An error is retriable if the same request may succeed if submitted again.
	Retriable bool
}

// EncodeJSON encodes Error into JSON.
func (v Error) EncodeJSON(b []byte) []byte {
	b = append(b, `{"code":`...)
	b = json.AppendInt(b, int64(v.Code))
	b = append(b, ","...)
	if v.Description.Set {
		b = append(b, `"description":`...)
		b = json.AppendString(b, v.Description.Value)
		b = append(b, ","...)
	}
	if len(v.Details) > 0 {
		b = append(b, `"details":`...)
		b = append(b, v.Details...)
		b = append(b, ","...)
	}
	b = append(b, `"message":`...)
	b = json.AppendString(b, v.Message)
	b = append(b, `,"retriable":`...)
	b = json.AppendBool(b, v.Retriable)
	return append(b, "}"...)
}

// Equal returns whether two Error values are equal.
func (v Error) Equal(o Error) bool {
	return v.Code == o.Code &&
		v.Description.Value == o.Description.Value &&
		v.Description.Set == o.Description.Set &&
		string(v.Details) == string(o.Details) &&
		v.Message == o.Message &&
		v.Retriable == o.Retriable
}

// Reset resets Error so that it can be reused.
func (v *Error) Reset() {
	v.Code = 0
	v.Description.Value = ""
	v.Description.Set = false
	v.Details = v.Details[:0]
	v.Message = ""
	v.Retriable = false
}

// EventsBlocksRequest is utilized to fetch a sequence of BlockEvents indicating
// which blocks were added and removed from storage to reach the current state.
type EventsBlocksRequest struct {
	// limit is the maximum number of events to fetch in one call. The
	// implementation may return <= limit events.
	Limit OptionalInt64Type
	// offset is the offset into the event stream to sync events from. If this
	// field is not populated, we return the limit events backwards from tip. If
	// this is set to 0, we start from the beginning.
	Offset OptionalInt64Type
}

// EncodeJSON encodes EventsBlocksRequest into JSON.
func (v EventsBlocksRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if v.Limit.Set {
		b = append(b, `"limit":`...)
		b = json.AppendInt(b, v.Limit.Value)
		b = append(b, ","...)
	}
	if v.Offset.Set {
		b = append(b, `"offset":`...)
		b = json.AppendInt(b, v.Offset.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two EventsBlocksRequest values are equal.
func (v EventsBlocksRequest) Equal(o EventsBlocksRequest) bool {
	return v.Limit.Value == o.Limit.Value &&
		v.Limit.Set == o.Limit.Set &&
		v.Offset.Value == o.Offset.Value &&
		v.Offset.Set == o.Offset.Set
}

// Reset resets EventsBlocksRequest so that it can be reused.
func (v *EventsBlocksRequest) Reset() {
	v.Limit.Value = 0
	v.Limit.Set = false
	v.Offset.Value = 0
	v.Offset.Set = false
}

// EventsBlocksResponse contains an ordered collection of BlockEvents and the
// max retrievable sequence.
type EventsBlocksResponse struct {
	// events is an array of BlockEvents indicating the order to add and remove
	// blocks to maintain a canonical view of blockchain state. Lightweight
	// clients can use this event stream to update state without implementing
	// their own block syncing logic.
	Events []BlockEvent
	// max_sequence is the maximum available sequence number to fetch.
	MaxSequence int64
}

// EncodeJSON encodes EventsBlocksResponse into JSON.
func (v EventsBlocksResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"events":[`...)
	for i, elem := range v.Events {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, ']', ',', '"', 'm', 'a', 'x', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '"', ':')
	b = json.AppendInt(b, v.MaxSequence)
	return append(b, "}"...)
}

// Equal returns whether two EventsBlocksResponse values are equal.
func (v EventsBlocksResponse) Equal(o EventsBlocksResponse) bool {
	return len(v.Events) == len(o.Events) &&
		blockEventSliceEqual(v.Events, o.Events) &&
		v.MaxSequence == o.MaxSequence
}

// Reset resets EventsBlocksResponse so that it can be reused.
func (v *EventsBlocksResponse) Reset() {
	v.Events = v.Events[:0]
	v.MaxSequence = 0
}

// ExemptionType is used to indicate if the live balance for an account subject
// to a BalanceExemption could increase above, decrease below, or equal the
// computed balance.
//
// * greater_or_equal: The live balance may increase above or equal the computed balance. This typically
// occurs with staking rewards that accrue on each block.
// * less_or_equal: The live balance may decrease below or equal the computed balance. This typically
// occurs as balance moves from locked to spendable on a vesting account.
// * dynamic: The live balance may increase above, decrease below, or equal the computed balance. This
// typically occurs with tokens that have a dynamic supply.
type ExemptionType string

// Validate the ExemptionType value.
func (v ExemptionType) Validate() error {
	if !(v == "dynamic" || v == "greater_or_equal" || v == "less_or_equal") {
		return fmt.Errorf("api: invalid ExemptionType value: %q", v)
	}
	return nil
}

// MempoolResponse type.
//
// A MempoolResponse contains all transaction identifiers in the mempool for a
// particular network_identifier.
type MempoolResponse struct {
	TransactionIdentifiers []TransactionIdentifier
}

// EncodeJSON encodes MempoolResponse into JSON.
func (v MempoolResponse) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 's', '"', ':', '[')
	for i, elem := range v.TransactionIdentifiers {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	return append(b, "]}"...)
}

// Equal returns whether two MempoolResponse values are equal.
func (v MempoolResponse) Equal(o MempoolResponse) bool {
	return len(v.TransactionIdentifiers) == len(o.TransactionIdentifiers) &&
		transactionIdentifierSliceEqual(v.TransactionIdentifiers, o.TransactionIdentifiers)
}

// Reset resets MempoolResponse so that it can be reused.
func (v *MempoolResponse) Reset() {
	v.TransactionIdentifiers = v.TransactionIdentifiers[:0]
}

// MempoolTransactionRequest type.
//
// A MempoolTransactionRequest is utilized to retrieve a transaction from the
// mempool.
type MempoolTransactionRequest struct {
	TransactionIdentifier TransactionIdentifier
}

// EncodeJSON encodes MempoolTransactionRequest into JSON.
func (v MempoolTransactionRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	b = append(b, '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.TransactionIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two MempoolTransactionRequest values are equal.
func (v MempoolTransactionRequest) Equal(o MempoolTransactionRequest) bool {
	return v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets MempoolTransactionRequest so that it can be reused.
func (v *MempoolTransactionRequest) Reset() {
	v.TransactionIdentifier.Reset()
}

// MempoolTransactionResponse type.
//
// A MempoolTransactionResponse contains an estimate of a mempool transaction.
// It may not be possible to know the full impact of a transaction in the
// mempool (ex: fee paid).
type MempoolTransactionResponse struct {
	Metadata    MapObject
	Transaction Transaction
}

// EncodeJSON encodes MempoolTransactionResponse into JSON.
func (v MempoolTransactionResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"transaction":`...)
	b = v.Transaction.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two MempoolTransactionResponse values are equal.
func (v MempoolTransactionResponse) Equal(o MempoolTransactionResponse) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.Transaction.Equal(o.Transaction)
}

// Reset resets MempoolTransactionResponse so that it can be reused.
func (v *MempoolTransactionResponse) Reset() {
	v.Metadata = v.Metadata[:0]
	v.Transaction.Reset()
}

// MetadataRequest type.
//
// A MetadataRequest is utilized in any request where the only argument is
// optional metadata.
type MetadataRequest struct {
	Metadata MapObject
}

// EncodeJSON encodes MetadataRequest into JSON.
func (v MetadataRequest) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
	}
	return append(b, "}"...)
}

// Equal returns whether two MetadataRequest values are equal.
func (v MetadataRequest) Equal(o MetadataRequest) bool {
	return string(v.Metadata) == string(o.Metadata)
}

// Reset resets MetadataRequest so that it can be reused.
func (v *MetadataRequest) Reset() {
	v.Metadata = v.Metadata[:0]
}

// NetworkIdentifier type.
//
// The network_identifier specifies which network a particular object is
// associated with.
type NetworkIdentifier struct {
	Blockchain string
	// If a blockchain has a specific chain-id or network identifier, it should
	// go in this field. It is up to the client to determine which
	// network-specific identifier is mainnet or testnet.
	Network              string
	SubNetworkIdentifier OptionalSubNetworkIdentifierType
}

// EncodeJSON encodes NetworkIdentifier into JSON.
func (v NetworkIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"blockchain":`...)
	b = json.AppendString(b, v.Blockchain)
	b = append(b, `,"network":`...)
	b = json.AppendString(b, v.Network)
	b = append(b, ","...)
	if v.SubNetworkIdentifier.Set {
		b = append(b, '"', 's', 'u', 'b', '_', 'n', 'e', 't', 'w', 'o', 'r', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.SubNetworkIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two NetworkIdentifier values are equal.
func (v NetworkIdentifier) Equal(o NetworkIdentifier) bool {
	return v.Blockchain == o.Blockchain &&
		v.Network == o.Network &&
		v.SubNetworkIdentifier.Value.Equal(o.SubNetworkIdentifier.Value) &&
		v.SubNetworkIdentifier.Set == o.SubNetworkIdentifier.Set
}

// Reset resets NetworkIdentifier so that it can be reused.
func (v *NetworkIdentifier) Reset() {
	v.Blockchain = ""
	v.Network = ""
	v.SubNetworkIdentifier.Value.Reset()
	v.SubNetworkIdentifier.Set = false
}

// NetworkListResponse type.
//
// A NetworkListResponse contains all NetworkIdentifiers that the node can serve
// information for.
type NetworkListResponse struct {
	NetworkIdentifiers []NetworkIdentifier
}

// EncodeJSON encodes NetworkListResponse into JSON.
func (v NetworkListResponse) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'n', 'e', 't', 'w', 'o', 'r', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', 's', '"', ':', '[')
	for i, elem := range v.NetworkIdentifiers {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	return append(b, "]}"...)
}

// Equal returns whether two NetworkListResponse values are equal.
func (v NetworkListResponse) Equal(o NetworkListResponse) bool {
	return len(v.NetworkIdentifiers) == len(o.NetworkIdentifiers) &&
		networkIdentifierSliceEqual(v.NetworkIdentifiers, o.NetworkIdentifiers)
}

// Reset resets NetworkListResponse so that it can be reused.
func (v *NetworkListResponse) Reset() {
	v.NetworkIdentifiers = v.NetworkIdentifiers[:0]
}

// NetworkOptionsResponse contains information about the versioning of the node
// and the allowed operation statuses, operation types, and errors.
type NetworkOptionsResponse struct {
	Allow   Allow
	Version Version
}

// EncodeJSON encodes NetworkOptionsResponse into JSON.
func (v NetworkOptionsResponse) EncodeJSON(b []byte) []byte {
	b = append(b, `{"allow":`...)
	b = v.Allow.EncodeJSON(b)
	b = append(b, `,"version":`...)
	b = v.Version.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two NetworkOptionsResponse values are equal.
func (v NetworkOptionsResponse) Equal(o NetworkOptionsResponse) bool {
	return v.Allow.Equal(o.Allow) &&
		v.Version.Equal(o.Version)
}

// Reset resets NetworkOptionsResponse so that it can be reused.
func (v *NetworkOptionsResponse) Reset() {
	v.Allow.Reset()
	v.Version.Reset()
}

// NetworkRequest type.
//
// A NetworkRequest is utilized to retrieve some data specific exclusively to a
// NetworkIdentifier.
type NetworkRequest struct {
	Metadata MapObject
}

// EncodeJSON encodes NetworkRequest into JSON.
func (v NetworkRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
	}
	return append(b, "}"...)
}

// Equal returns whether two NetworkRequest values are equal.
func (v NetworkRequest) Equal(o NetworkRequest) bool {
	return string(v.Metadata) == string(o.Metadata)
}

// Reset resets NetworkRequest so that it can be reused.
func (v *NetworkRequest) Reset() {
	v.Metadata = v.Metadata[:0]
}

// NetworkStatusResponse contains basic information about the node's view of a
// blockchain network. It is assumed that any BlockIdentifier.Index less than or
// equal to CurrentBlockIdentifier.Index can be queried.
//
// If a Rosetta implementation prunes historical state, it should populate the
// optional `oldest_block_identifier` field with the oldest block available to
// query. If this is not populated, it is assumed that the
// `genesis_block_identifier` is the oldest queryable block.
//
// If a Rosetta implementation performs some pre-sync before it is possible to
// query blocks, sync_status should be populated so that clients can still
// monitor healthiness. Without this field, it may appear that the
// implementation is stuck syncing and needs to be terminated.
type NetworkStatusResponse struct {
	CurrentBlockIdentifier BlockIdentifier
	CurrentBlockTimestamp  Timestamp
	GenesisBlockIdentifier BlockIdentifier
	OldestBlockIdentifier  OptionalBlockIdentifierType
	Peers                  []Peer
	SyncStatus             OptionalSyncStatusType
}

// EncodeJSON encodes NetworkStatusResponse into JSON.
func (v NetworkStatusResponse) EncodeJSON(b []byte) []byte {
	b = append(b, '{', '"', 'c', 'u', 'r', 'r', 'e', 'n', 't', '_', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.CurrentBlockIdentifier.EncodeJSON(b)
	b = append(b, ',', '"', 'c', 'u', 'r', 'r', 'e', 'n', 't', '_', 'b', 'l', 'o', 'c', 'k', '_', 't', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', '"', ':')
	b = json.AppendInt(b, int64(v.CurrentBlockTimestamp))
	b = append(b, ',', '"', 'g', 'e', 'n', 'e', 's', 'i', 's', '_', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.GenesisBlockIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if v.OldestBlockIdentifier.Set {
		b = append(b, '"', 'o', 'l', 'd', 'e', 's', 't', '_', 'b', 'l', 'o', 'c', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.OldestBlockIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	b = append(b, `"peers":[`...)
	for i, elem := range v.Peers {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if v.SyncStatus.Set {
		b = append(b, `"sync_status":`...)
		b = v.SyncStatus.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two NetworkStatusResponse values are equal.
func (v NetworkStatusResponse) Equal(o NetworkStatusResponse) bool {
	return v.CurrentBlockIdentifier.Equal(o.CurrentBlockIdentifier) &&
		v.CurrentBlockTimestamp == o.CurrentBlockTimestamp &&
		v.GenesisBlockIdentifier.Equal(o.GenesisBlockIdentifier) &&
		v.OldestBlockIdentifier.Value.Equal(o.OldestBlockIdentifier.Value) &&
		v.OldestBlockIdentifier.Set == o.OldestBlockIdentifier.Set &&
		len(v.Peers) == len(o.Peers) &&
		peerSliceEqual(v.Peers, o.Peers) &&
		v.SyncStatus.Value.Equal(o.SyncStatus.Value) &&
		v.SyncStatus.Set == o.SyncStatus.Set
}

// Reset resets NetworkStatusResponse so that it can be reused.
func (v *NetworkStatusResponse) Reset() {
	v.CurrentBlockIdentifier.Reset()
	v.CurrentBlockTimestamp = 0
	v.GenesisBlockIdentifier.Reset()
	v.OldestBlockIdentifier.Value.Reset()
	v.OldestBlockIdentifier.Set = false
	v.Peers = v.Peers[:0]
	v.SyncStatus.Value.Reset()
	v.SyncStatus.Set = false
}

// Operation type.
//
// Operations contain all balance-changing information within a transaction.
// They are always one-sided (only affect 1 AccountIdentifier) and can succeed
// or fail independently from a Transaction.
//
// Operations are used both to represent on-chain data (Data API) and to
// construct new transactions (Construction API), creating a standard interface
// for reading and writing to blockchains.
type Operation struct {
	Account             OptionalAccountIdentifierType
	Amount              OptionalAmountType
	CoinChange          OptionalCoinChangeType
	Metadata            MapObject
	OperationIdentifier OperationIdentifier
	// Restrict referenced related_operations to identifier indices < the
	// current operation_identifier.index. This ensures there exists a clear
	// DAG-structure of relations.
	//
	// Since operations are one-sided, one could imagine relating operations in
	// a single transfer or linking operations in a call tree.
	RelatedOperations []OperationIdentifier
	// Status is the network-specific status of the operation. Status is not
	// defined on the transaction object because blockchains with smart
	// contracts may have transactions that partially apply (some operations are
	// successful and some are not). Blockchains with atomic transactions (all
	// operations succeed or all operations fail) will have the same status for
	// each operation.
	//
	// On-chain operations (operations retrieved in the `/block` and
	// `/block/transaction` endpoints) MUST have a populated status field
	// (anything on-chain must have succeeded or failed). However, operations
	// provided during transaction construction (often times called "intent" in
	// the documentation) MUST NOT have a populated status field (operations yet
	// to be included on-chain have not yet succeeded or failed).
	Status OptionalStringType
	// Type is the network-specific type of the operation. Ensure that any type
	// that can be returned here is also specified in the
	// NetworkOptionsResponse. This can be very useful to downstream consumers
	// that parse all block data.
	Type string
}

// EncodeJSON encodes Operation into JSON.
func (v Operation) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.Account.Set {
		b = append(b, `"account":`...)
		b = v.Account.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Amount.Set {
		b = append(b, `"amount":`...)
		b = v.Amount.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.CoinChange.Set {
		b = append(b, `"coin_change":`...)
		b = v.CoinChange.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, '"', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.OperationIdentifier.EncodeJSON(b)
	b = append(b, ","...)
	if len(v.RelatedOperations) > 0 {
		b = append(b, '"', 'r', 'e', 'l', 'a', 't', 'e', 'd', '_', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', '"', ':', '[')
		for i, elem := range v.RelatedOperations {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	if v.Status.Set {
		b = append(b, `"status":`...)
		b = json.AppendString(b, v.Status.Value)
		b = append(b, ","...)
	}
	b = append(b, `"type":`...)
	b = json.AppendString(b, v.Type)
	return append(b, "}"...)
}

// Equal returns whether two Operation values are equal.
func (v Operation) Equal(o Operation) bool {
	return v.Account.Value.Equal(o.Account.Value) &&
		v.Account.Set == o.Account.Set &&
		v.Amount.Value.Equal(o.Amount.Value) &&
		v.Amount.Set == o.Amount.Set &&
		v.CoinChange.Value.Equal(o.CoinChange.Value) &&
		v.CoinChange.Set == o.CoinChange.Set &&
		string(v.Metadata) == string(o.Metadata) &&
		v.OperationIdentifier.Equal(o.OperationIdentifier) &&
		len(v.RelatedOperations) == len(o.RelatedOperations) &&
		operationIdentifierSliceEqual(v.RelatedOperations, o.RelatedOperations) &&
		v.Status.Value == o.Status.Value &&
		v.Status.Set == o.Status.Set &&
		v.Type == o.Type
}

// Reset resets Operation so that it can be reused.
func (v *Operation) Reset() {
	v.Account.Value.Reset()
	v.Account.Set = false
	v.Amount.Value.Reset()
	v.Amount.Set = false
	v.CoinChange.Value.Reset()
	v.CoinChange.Set = false
	v.Metadata = v.Metadata[:0]
	v.OperationIdentifier.Reset()
	v.RelatedOperations = v.RelatedOperations[:0]
	v.Status.Value = ""
	v.Status.Set = false
	v.Type = ""
}

// OperationIdentifier type.
//
// The operation_identifier uniquely identifies an operation within a
// transaction.
type OperationIdentifier struct {
	// The operation index is used to ensure each operation has a unique
	// identifier within a transaction. This index is only relative to the
	// transaction and NOT GLOBAL. The operations in each transaction should
	// start from index 0.
	//
	// To clarify, there may not be any notion of an operation index in the
	// blockchain being described.
	Index int64
	// Some blockchains specify an operation index that is essential for client
	// use. For example, Bitcoin uses a network_index to identify which UTXO was
	// used in a transaction.
	//
	// network_index should not be populated if there is no notion of an
	// operation index in a blockchain (typically most account-based
	// blockchains).
	NetworkIndex OptionalInt64Type
}

// EncodeJSON encodes OperationIdentifier into JSON.
func (v OperationIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"index":`...)
	b = json.AppendInt(b, v.Index)
	b = append(b, ","...)
	if v.NetworkIndex.Set {
		b = append(b, `"network_index":`...)
		b = json.AppendInt(b, v.NetworkIndex.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two OperationIdentifier values are equal.
func (v OperationIdentifier) Equal(o OperationIdentifier) bool {
	return v.Index == o.Index &&
		v.NetworkIndex.Value == o.NetworkIndex.Value &&
		v.NetworkIndex.Set == o.NetworkIndex.Set
}

// Reset resets OperationIdentifier so that it can be reused.
func (v *OperationIdentifier) Reset() {
	v.Index = 0
	v.NetworkIndex.Value = 0
	v.NetworkIndex.Set = false
}

// OperationStatus is utilized to indicate which Operation status are considered
// successful.
type OperationStatus struct {
	// The status is the network-specific status of the operation.
	Status string
	// An Operation is considered successful if the Operation.Amount should
	// affect the Operation.Account. Some blockchains (like Bitcoin) only
	// include successful operations in blocks but other blockchains (like
	// Ethereum) include unsuccessful operations that incur a fee.
	//
	// To reconcile the computed balance from the stream of Operations, it is
	// critical to understand which Operation.Status indicate an Operation is
	// successful and should affect an Account.
	Successful bool
}

// EncodeJSON encodes OperationStatus into JSON.
func (v OperationStatus) EncodeJSON(b []byte) []byte {
	b = append(b, `{"status":`...)
	b = json.AppendString(b, v.Status)
	b = append(b, `,"successful":`...)
	b = json.AppendBool(b, v.Successful)
	return append(b, "}"...)
}

// Equal returns whether two OperationStatus values are equal.
func (v OperationStatus) Equal(o OperationStatus) bool {
	return v.Status == o.Status &&
		v.Successful == o.Successful
}

// Reset resets OperationStatus so that it can be reused.
func (v *OperationStatus) Reset() {
	v.Status = ""
	v.Successful = false
}

// Operator is used by query-related endpoints to determine how to apply
// conditions.
//
// If this field is not populated, the default `and` value will be used.
type Operator string

// Validate the Operator value.
func (v Operator) Validate() error {
	if !(v == "and" || v == "or") {
		return fmt.Errorf("api: invalid Operator value: %q", v)
	}
	return nil
}

// PartialBlockIdentifier type.
//
// When fetching data by BlockIdentifier, it may be possible to only specify the
// index or hash. If neither property is specified, it is assumed that the
// client is making a request at the current block.
type PartialBlockIdentifier struct {
	Hash  OptionalStringType
	Index OptionalInt64Type
}

// EncodeJSON encodes PartialBlockIdentifier into JSON.
func (v PartialBlockIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.Hash.Set {
		b = append(b, `"hash":`...)
		b = json.AppendString(b, v.Hash.Value)
		b = append(b, ","...)
	}
	if v.Index.Set {
		b = append(b, `"index":`...)
		b = json.AppendInt(b, v.Index.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two PartialBlockIdentifier values are equal.
func (v PartialBlockIdentifier) Equal(o PartialBlockIdentifier) bool {
	return v.Hash.Value == o.Hash.Value &&
		v.Hash.Set == o.Hash.Set &&
		v.Index.Value == o.Index.Value &&
		v.Index.Set == o.Index.Set
}

// Reset resets PartialBlockIdentifier so that it can be reused.
func (v *PartialBlockIdentifier) Reset() {
	v.Hash.Value = ""
	v.Hash.Set = false
	v.Index.Value = 0
	v.Index.Set = false
}

// Peer type.
//
// A Peer is a representation of a node's peer.
type Peer struct {
	Metadata MapObject
	PeerID   string
}

// EncodeJSON encodes Peer into JSON.
func (v Peer) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"peer_id":`...)
	b = json.AppendString(b, v.PeerID)
	return append(b, "}"...)
}

// Equal returns whether two Peer values are equal.
func (v Peer) Equal(o Peer) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.PeerID == o.PeerID
}

// Reset resets Peer so that it can be reused.
func (v *Peer) Reset() {
	v.Metadata = v.Metadata[:0]
	v.PeerID = ""
}

// PublicKey contains a public key byte array for a particular CurveType encoded
// in hex.
//
// Note that there is no PrivateKey struct as this is NEVER the concern of an
// implementation.
type PublicKey struct {
	// Hex-encoded public key bytes in the format specified by the CurveType.
	Bytes     []byte
	CurveType CurveType
}

// EncodeJSON encodes PublicKey into JSON.
func (v PublicKey) EncodeJSON(b []byte) []byte {
	b = append(b, `{"hex_bytes":`...)
	b = json.AppendHexBytes(b, v.Bytes)
	b = append(b, `,"curve_type":`...)
	b = json.AppendString(b, string(v.CurveType))
	return append(b, "}"...)
}

// Equal returns whether two PublicKey values are equal.
func (v PublicKey) Equal(o PublicKey) bool {
	return string(v.Bytes) == string(o.Bytes) &&
		v.CurveType == o.CurveType
}

// Reset resets PublicKey so that it can be reused.
func (v *PublicKey) Reset() {
	v.Bytes = v.Bytes[:0]
	v.CurveType = ""
}

// RelatedTransaction type.
//
// The related_transaction allows implementations to link together multiple
// transactions. An unpopulated network identifier indicates that the related
// transaction is on the same network.
type RelatedTransaction struct {
	Direction             Direction
	NetworkIdentifier     OptionalNetworkIdentifierType
	TransactionIdentifier TransactionIdentifier
}

// EncodeJSON encodes RelatedTransaction into JSON.
func (v RelatedTransaction) EncodeJSON(b []byte) []byte {
	b = append(b, `{"direction":`...)
	b = json.AppendString(b, string(v.Direction))
	b = append(b, ","...)
	if v.NetworkIdentifier.Set {
		b = append(b, '"', 'n', 'e', 't', 'w', 'o', 'r', 'k', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.NetworkIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	b = append(b, '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.TransactionIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two RelatedTransaction values are equal.
func (v RelatedTransaction) Equal(o RelatedTransaction) bool {
	return v.Direction == o.Direction &&
		v.NetworkIdentifier.Value.Equal(o.NetworkIdentifier.Value) &&
		v.NetworkIdentifier.Set == o.NetworkIdentifier.Set &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets RelatedTransaction so that it can be reused.
func (v *RelatedTransaction) Reset() {
	v.Direction = ""
	v.NetworkIdentifier.Value.Reset()
	v.NetworkIdentifier.Set = false
	v.TransactionIdentifier.Reset()
}

// SearchTransactionsRequest is used to search for transactions matching a set
// of provided conditions in canonical blocks.
type SearchTransactionsRequest struct {
	AccountIdentifier OptionalAccountIdentifierType
	// address is AccountIdentifier.Address. This is used to get all
	// transactions related to an AccountIdentifier.Address, regardless of
	// SubAccountIdentifier.
	Address        OptionalStringType
	CoinIdentifier OptionalCoinIdentifierType
	Currency       OptionalCurrencyType
	// limit is the maximum number of transactions to return in one call. The
	// implementation may return <= limit transactions.
	Limit OptionalInt64Type
	// max_block is the largest block index to consider when searching for
	// transactions. If this field is not populated, the current block is
	// considered the max_block.
	//
	// If you do not specify a max_block, it is possible a newly synced block
	// will interfere with paginated transaction queries (as the offset could
	// become invalid with newly added rows).
	MaxBlock OptionalInt64Type
	// offset is the offset into the query result to start returning
	// transactions.
	//
	// If any search conditions are changed, the query offset will change and
	// you must restart your search iteration.
	Offset   OptionalInt64Type
	Operator OptionalOperatorType
	// status is the network-specific operation type.
	Status OptionalStringType
	// success is a synthetic condition populated by parsing network-specific
	// operation statuses (using the mapping provided in `/network/options`).
	Success               OptionalBoolType
	TransactionIdentifier OptionalTransactionIdentifierType
	// type is the network-specific operation type.
	Type OptionalStringType
}

// EncodeJSON encodes SearchTransactionsRequest into JSON.
func (v SearchTransactionsRequest) EncodeJSON(b []byte, network []byte) []byte {
	b = append(b, network...)
	if v.AccountIdentifier.Set {
		b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.AccountIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Address.Set {
		b = append(b, `"address":`...)
		b = json.AppendString(b, v.Address.Value)
		b = append(b, ","...)
	}
	if v.CoinIdentifier.Set {
		b = append(b, '"', 'c', 'o', 'i', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.CoinIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Currency.Set {
		b = append(b, `"currency":`...)
		b = v.Currency.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Limit.Set {
		b = append(b, `"limit":`...)
		b = json.AppendInt(b, v.Limit.Value)
		b = append(b, ","...)
	}
	if v.MaxBlock.Set {
		b = append(b, `"max_block":`...)
		b = json.AppendInt(b, v.MaxBlock.Value)
		b = append(b, ","...)
	}
	if v.Offset.Set {
		b = append(b, `"offset":`...)
		b = json.AppendInt(b, v.Offset.Value)
		b = append(b, ","...)
	}
	if v.Operator.Set {
		b = append(b, `"operator":`...)
		b = json.AppendString(b, string(v.Operator.Value))
		b = append(b, ","...)
	}
	if v.Status.Set {
		b = append(b, `"status":`...)
		b = json.AppendString(b, v.Status.Value)
		b = append(b, ","...)
	}
	if v.Success.Set {
		b = append(b, `"success":`...)
		b = json.AppendBool(b, v.Success.Value)
		b = append(b, ","...)
	}
	if v.TransactionIdentifier.Set {
		b = append(b, '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.TransactionIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Type.Set {
		b = append(b, `"type":`...)
		b = json.AppendString(b, v.Type.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two SearchTransactionsRequest values are equal.
func (v SearchTransactionsRequest) Equal(o SearchTransactionsRequest) bool {
	return v.AccountIdentifier.Value.Equal(o.AccountIdentifier.Value) &&
		v.AccountIdentifier.Set == o.AccountIdentifier.Set &&
		v.Address.Value == o.Address.Value &&
		v.Address.Set == o.Address.Set &&
		v.CoinIdentifier.Value.Equal(o.CoinIdentifier.Value) &&
		v.CoinIdentifier.Set == o.CoinIdentifier.Set &&
		v.Currency.Value.Equal(o.Currency.Value) &&
		v.Currency.Set == o.Currency.Set &&
		v.Limit.Value == o.Limit.Value &&
		v.Limit.Set == o.Limit.Set &&
		v.MaxBlock.Value == o.MaxBlock.Value &&
		v.MaxBlock.Set == o.MaxBlock.Set &&
		v.Offset.Value == o.Offset.Value &&
		v.Offset.Set == o.Offset.Set &&
		v.Operator.Value == o.Operator.Value &&
		v.Operator.Set == o.Operator.Set &&
		v.Status.Value == o.Status.Value &&
		v.Status.Set == o.Status.Set &&
		v.Success.Value == o.Success.Value &&
		v.Success.Set == o.Success.Set &&
		v.TransactionIdentifier.Value.Equal(o.TransactionIdentifier.Value) &&
		v.TransactionIdentifier.Set == o.TransactionIdentifier.Set &&
		v.Type.Value == o.Type.Value &&
		v.Type.Set == o.Type.Set
}

// Reset resets SearchTransactionsRequest so that it can be reused.
func (v *SearchTransactionsRequest) Reset() {
	v.AccountIdentifier.Value.Reset()
	v.AccountIdentifier.Set = false
	v.Address.Value = ""
	v.Address.Set = false
	v.CoinIdentifier.Value.Reset()
	v.CoinIdentifier.Set = false
	v.Currency.Value.Reset()
	v.Currency.Set = false
	v.Limit.Value = 0
	v.Limit.Set = false
	v.MaxBlock.Value = 0
	v.MaxBlock.Set = false
	v.Offset.Value = 0
	v.Offset.Set = false
	v.Operator.Value = ""
	v.Operator.Set = false
	v.Status.Value = ""
	v.Status.Set = false
	v.Success.Value = false
	v.Success.Set = false
	v.TransactionIdentifier.Value.Reset()
	v.TransactionIdentifier.Set = false
	v.Type.Value = ""
	v.Type.Set = false
}

// SearchTransactionsResponse contains an ordered collection of
// BlockTransactions that match the query in SearchTransactionsRequest. These
// BlockTransactions are sorted from most recent block to oldest block.
type SearchTransactionsResponse struct {
	// next_offset is the next offset to use when paginating through transaction
	// results. If this field is not populated, there are no more transactions
	// to query.
	NextOffset OptionalInt64Type
	// total_count is the number of results for a given search. Callers
	// typically use this value to concurrently fetch results by offset or to
	// display a virtual page number associated with results.
	TotalCount int64
	// transactions is an array of BlockTransactions sorted by most recent
	// BlockIdentifier (meaning that transactions in recent blocks appear
	// first).
	//
	// If there are many transactions for a particular search, transactions may
	// not contain all matching transactions. It is up to the caller to paginate
	// these transactions using the max_block field.
	Transactions []BlockTransaction
}

// EncodeJSON encodes SearchTransactionsResponse into JSON.
func (v SearchTransactionsResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.NextOffset.Set {
		b = append(b, `"next_offset":`...)
		b = json.AppendInt(b, v.NextOffset.Value)
		b = append(b, ","...)
	}
	b = append(b, `"total_count":`...)
	b = json.AppendInt(b, v.TotalCount)
	b = append(b, ',', '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', 's', '"', ':', '[')
	for i, elem := range v.Transactions {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	return append(b, "]}"...)
}

// Equal returns whether two SearchTransactionsResponse values are equal.
func (v SearchTransactionsResponse) Equal(o SearchTransactionsResponse) bool {
	return v.NextOffset.Value == o.NextOffset.Value &&
		v.NextOffset.Set == o.NextOffset.Set &&
		v.TotalCount == o.TotalCount &&
		len(v.Transactions) == len(o.Transactions) &&
		blockTransactionSliceEqual(v.Transactions, o.Transactions)
}

// Reset resets SearchTransactionsResponse so that it can be reused.
func (v *SearchTransactionsResponse) Reset() {
	v.NextOffset.Value = 0
	v.NextOffset.Set = false
	v.TotalCount = 0
	v.Transactions = v.Transactions[:0]
}

// Signature contains the payload that was signed, the public keys of the
// keypairs used to produce the signature, the signature (encoded in hex), and
// the SignatureType.
//
// PublicKey is often times not known during construction of the signing
// payloads but may be needed to combine signatures properly.
type Signature struct {
	Bytes          []byte
	PublicKey      PublicKey
	SignatureType  SignatureType
	SigningPayload SigningPayload
}

// EncodeJSON encodes Signature into JSON.
func (v Signature) EncodeJSON(b []byte) []byte {
	b = append(b, `{"hex_bytes":`...)
	b = json.AppendHexBytes(b, v.Bytes)
	b = append(b, `,"public_key":`...)
	b = v.PublicKey.EncodeJSON(b)
	b = append(b, ',', '"', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', '_', 't', 'y', 'p', 'e', '"', ':')
	b = json.AppendString(b, string(v.SignatureType))
	b = append(b, ',', '"', 's', 'i', 'g', 'n', 'i', 'n', 'g', '_', 'p', 'a', 'y', 'l', 'o', 'a', 'd', '"', ':')
	b = v.SigningPayload.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two Signature values are equal.
func (v Signature) Equal(o Signature) bool {
	return string(v.Bytes) == string(o.Bytes) &&
		v.PublicKey.Equal(o.PublicKey) &&
		v.SignatureType == o.SignatureType &&
		v.SigningPayload.Equal(o.SigningPayload)
}

// Reset resets Signature so that it can be reused.
func (v *Signature) Reset() {
	v.Bytes = v.Bytes[:0]
	v.PublicKey.Reset()
	v.SignatureType = ""
	v.SigningPayload.Reset()
}

// SignatureType is the type of a cryptographic signature.
//
// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
type SignatureType string

// Validate the SignatureType value.
func (v SignatureType) Validate() error {
	if !(v == "ecdsa" || v == "ecdsa_recovery" || v == "ed25519" || v == "schnorr_1" || v == "schnorr_poseidon") {
		return fmt.Errorf("api: invalid SignatureType value: %q", v)
	}
	return nil
}

// SigningPayload is signed by the client with the keypair associated with an
// AccountIdentifier using the specified SignatureType.
//
// SignatureType can be optionally populated if there is a restriction on the
// signature scheme that can be used to sign the payload.
type SigningPayload struct {
	AccountIdentifier OptionalAccountIdentifierType
	// [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific
	// address of the account that should sign the payload.
	Address       OptionalStringType
	Bytes         []byte
	SignatureType OptionalSignatureTypeType
}

// EncodeJSON encodes SigningPayload into JSON.
func (v SigningPayload) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.AccountIdentifier.Set {
		b = append(b, '"', 'a', 'c', 'c', 'o', 'u', 'n', 't', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
		b = v.AccountIdentifier.Value.EncodeJSON(b)
		b = append(b, ","...)
	}
	if v.Address.Set {
		b = append(b, `"address":`...)
		b = json.AppendString(b, v.Address.Value)
		b = append(b, ","...)
	}
	b = append(b, `"hex_bytes":`...)
	b = json.AppendHexBytes(b, v.Bytes)
	b = append(b, ","...)
	if v.SignatureType.Set {
		b = append(b, '"', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', '_', 't', 'y', 'p', 'e', '"', ':')
		b = json.AppendString(b, string(v.SignatureType.Value))
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two SigningPayload values are equal.
func (v SigningPayload) Equal(o SigningPayload) bool {
	return v.AccountIdentifier.Value.Equal(o.AccountIdentifier.Value) &&
		v.AccountIdentifier.Set == o.AccountIdentifier.Set &&
		v.Address.Value == o.Address.Value &&
		v.Address.Set == o.Address.Set &&
		string(v.Bytes) == string(o.Bytes) &&
		v.SignatureType.Value == o.SignatureType.Value &&
		v.SignatureType.Set == o.SignatureType.Set
}

// Reset resets SigningPayload so that it can be reused.
func (v *SigningPayload) Reset() {
	v.AccountIdentifier.Value.Reset()
	v.AccountIdentifier.Set = false
	v.Address.Value = ""
	v.Address.Set = false
	v.Bytes = v.Bytes[:0]
	v.SignatureType.Value = ""
	v.SignatureType.Set = false
}

// SubAccountIdentifier type.
//
// An account may have state specific to a contract address (ERC-20 token)
// and/or a stake (delegated balance). The sub_account_identifier should specify
// which state (if applicable) an account instantiation refers to.
type SubAccountIdentifier struct {
	// The SubAccount address may be a cryptographic value or some other
	// identifier (ex: bonded) that uniquely specifies a SubAccount.
	Address string
	// If the SubAccount address is not sufficient to uniquely specify a
	// SubAccount, any other identifying information can be stored here.
	//
	// It is important to note that two SubAccounts with identical addresses but
	// differing metadata will not be considered equal by clients.
	Metadata MapObject
}

// EncodeJSON encodes SubAccountIdentifier into JSON.
func (v SubAccountIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"address":`...)
	b = json.AppendString(b, v.Address)
	b = append(b, ","...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two SubAccountIdentifier values are equal.
func (v SubAccountIdentifier) Equal(o SubAccountIdentifier) bool {
	return v.Address == o.Address &&
		string(v.Metadata) == string(o.Metadata)
}

// Reset resets SubAccountIdentifier so that it can be reused.
func (v *SubAccountIdentifier) Reset() {
	v.Address = ""
	v.Metadata = v.Metadata[:0]
}

// SubNetworkIdentifier type.
//
// In blockchains with sharded state, the SubNetworkIdentifier is required to
// query some object on a specific shard. This identifier is optional for all
// non-sharded blockchains.
type SubNetworkIdentifier struct {
	Metadata MapObject
	Network  string
}

// EncodeJSON encodes SubNetworkIdentifier into JSON.
func (v SubNetworkIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"network":`...)
	b = json.AppendString(b, v.Network)
	return append(b, "}"...)
}

// Equal returns whether two SubNetworkIdentifier values are equal.
func (v SubNetworkIdentifier) Equal(o SubNetworkIdentifier) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.Network == o.Network
}

// Reset resets SubNetworkIdentifier so that it can be reused.
func (v *SubNetworkIdentifier) Reset() {
	v.Metadata = v.Metadata[:0]
	v.Network = ""
}

// SyncStatus is used to provide additional context about an implementation's
// sync status.
//
// This object is often used by implementations to indicate healthiness when
// block data cannot be queried until some sync phase completes or cannot be
// determined by comparing the timestamp of the most recent block with the
// current time.
type SyncStatus struct {
	// CurrentIndex is the index of the last synced block in the current stage.
	//
	// This is a separate field from current_block_identifier in
	// NetworkStatusResponse because blocks with indices up to and including the
	// current_index may not yet be queryable by the caller. To reiterate, all
	// indices up to and including current_block_identifier in
	// NetworkStatusResponse must be queryable via the /block endpoint
	// (excluding indices less than oldest_block_identifier).
	CurrentIndex OptionalInt64Type
	// Stage is the phase of the sync process.
	Stage OptionalStringType
	// sycned is a boolean that indicates if an implementation has synced up to
	// the most recent block. If this field is not populated, the caller should
	// rely on a traditional tip timestamp comparison to determine if an
	// implementation is synced.
	//
	// This field is particularly useful for quiescent blockchains (blocks only
	// produced when there are pending transactions). In these blockchains, the
	// most recent block could have a timestamp far behind the current time but
	// the node could be healthy and at tip.
	Synced OptionalBoolType
	// TargetIndex is the index of the block that the implementation is
	// attempting to sync to in the current stage.
	TargetIndex OptionalInt64Type
}

// EncodeJSON encodes SyncStatus into JSON.
func (v SyncStatus) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if v.CurrentIndex.Set {
		b = append(b, `"current_index":`...)
		b = json.AppendInt(b, v.CurrentIndex.Value)
		b = append(b, ","...)
	}
	if v.Stage.Set {
		b = append(b, `"stage":`...)
		b = json.AppendString(b, v.Stage.Value)
		b = append(b, ","...)
	}
	if v.Synced.Set {
		b = append(b, `"synced":`...)
		b = json.AppendBool(b, v.Synced.Value)
		b = append(b, ","...)
	}
	if v.TargetIndex.Set {
		b = append(b, `"target_index":`...)
		b = json.AppendInt(b, v.TargetIndex.Value)
		b = append(b, ","...)
	}
	b[len(b)-1] = '}'
	return b
}

// Equal returns whether two SyncStatus values are equal.
func (v SyncStatus) Equal(o SyncStatus) bool {
	return v.CurrentIndex.Value == o.CurrentIndex.Value &&
		v.CurrentIndex.Set == o.CurrentIndex.Set &&
		v.Stage.Value == o.Stage.Value &&
		v.Stage.Set == o.Stage.Set &&
		v.Synced.Value == o.Synced.Value &&
		v.Synced.Set == o.Synced.Set &&
		v.TargetIndex.Value == o.TargetIndex.Value &&
		v.TargetIndex.Set == o.TargetIndex.Set
}

// Reset resets SyncStatus so that it can be reused.
func (v *SyncStatus) Reset() {
	v.CurrentIndex.Value = 0
	v.CurrentIndex.Set = false
	v.Stage.Value = ""
	v.Stage.Set = false
	v.Synced.Value = false
	v.Synced.Set = false
	v.TargetIndex.Value = 0
	v.TargetIndex.Set = false
}

// Timestamp type.
//
// The timestamp of the block in milliseconds since the Unix Epoch. The
// timestamp is stored in milliseconds because some blockchains produce blocks
// more often than once a second.
type Timestamp int64

// Validate the Timestamp value.
func (v Timestamp) Validate() error {
	if v < 0 {
		return fmt.Errorf("api: Timestamp value cannot be negative: %d", v)
	}
	return nil
}

// Transaction type.
//
// Transactions contain an array of Operations that are attributable to the same
// TransactionIdentifier.
type Transaction struct {
	// Transactions that are related to other transactions (like a cross-shard
	// transaction) should include the tranaction_identifier of these
	// transactions in the metadata.
	Metadata              MapObject
	Operations            []Operation
	RelatedTransactions   []RelatedTransaction
	TransactionIdentifier TransactionIdentifier
}

// EncodeJSON encodes Transaction into JSON.
func (v Transaction) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, `"operations":[`...)
	for i, elem := range v.Operations {
		if i != 0 {
			b = append(b, ","...)
		}
		b = elem.EncodeJSON(b)
	}
	b = append(b, "],"...)
	if len(v.RelatedTransactions) > 0 {
		b = append(b, '"', 'r', 'e', 'l', 'a', 't', 'e', 'd', '_', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', 's', '"', ':', '[')
		for i, elem := range v.RelatedTransactions {
			if i != 0 {
				b = append(b, ","...)
			}
			b = elem.EncodeJSON(b)
		}
		b = append(b, "],"...)
	}
	b = append(b, '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.TransactionIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two Transaction values are equal.
func (v Transaction) Equal(o Transaction) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		len(v.Operations) == len(o.Operations) &&
		operationSliceEqual(v.Operations, o.Operations) &&
		len(v.RelatedTransactions) == len(o.RelatedTransactions) &&
		relatedTransactionSliceEqual(v.RelatedTransactions, o.RelatedTransactions) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets Transaction so that it can be reused.
func (v *Transaction) Reset() {
	v.Metadata = v.Metadata[:0]
	v.Operations = v.Operations[:0]
	v.RelatedTransactions = v.RelatedTransactions[:0]
	v.TransactionIdentifier.Reset()
}

// TransactionIdentifier type.
//
// The transaction_identifier uniquely identifies a transaction in a particular
// network and block or in the mempool.
type TransactionIdentifier struct {
	// Any transactions that are attributable only to a block (ex: a block
	// event) should use the hash of the block as the identifier.
	Hash string
}

// EncodeJSON encodes TransactionIdentifier into JSON.
func (v TransactionIdentifier) EncodeJSON(b []byte) []byte {
	b = append(b, `{"hash":`...)
	b = json.AppendString(b, v.Hash)
	return append(b, "}"...)
}

// Equal returns whether two TransactionIdentifier values are equal.
func (v TransactionIdentifier) Equal(o TransactionIdentifier) bool {
	return v.Hash == o.Hash
}

// Reset resets TransactionIdentifier so that it can be reused.
func (v *TransactionIdentifier) Reset() {
	v.Hash = ""
}

// TransactionIdentifierResponse contains the transaction_identifier of a
// transaction that was submitted to either `/construction/hash` or
// `/construction/submit`.
type TransactionIdentifierResponse struct {
	Metadata              MapObject
	TransactionIdentifier TransactionIdentifier
}

// EncodeJSON encodes TransactionIdentifierResponse into JSON.
func (v TransactionIdentifierResponse) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	b = append(b, '"', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '_', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', '"', ':')
	b = v.TransactionIdentifier.EncodeJSON(b)
	return append(b, "}"...)
}

// Equal returns whether two TransactionIdentifierResponse values are equal.
func (v TransactionIdentifierResponse) Equal(o TransactionIdentifierResponse) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.TransactionIdentifier.Equal(o.TransactionIdentifier)
}

// Reset resets TransactionIdentifierResponse so that it can be reused.
func (v *TransactionIdentifierResponse) Reset() {
	v.Metadata = v.Metadata[:0]
	v.TransactionIdentifier.Reset()
}

// Version type.
//
// The Version object is utilized to inform the client of the versions of
// different components of the Rosetta implementation.
type Version struct {
	// Any other information that may be useful about versioning of dependent
	// services should be returned here.
	Metadata MapObject
	// When a middleware server is used to adhere to the Rosetta interface, it
	// should return its version here. This can help clients manage deployments.
	MiddlewareVersion OptionalStringType
	// The node_version is the canonical version of the node runtime. This can
	// help clients manage deployments.
	NodeVersion string
	// The rosetta_version is the version of the Rosetta interface the
	// implementation adheres to. This can be useful for clients looking to
	// reliably parse responses.
	RosettaVersion string
}

// EncodeJSON encodes Version into JSON.
func (v Version) EncodeJSON(b []byte) []byte {
	b = append(b, "{"...)
	if len(v.Metadata) > 0 {
		b = append(b, `"metadata":`...)
		b = append(b, v.Metadata...)
		b = append(b, ","...)
	}
	if v.MiddlewareVersion.Set {
		b = append(b, '"', 'm', 'i', 'd', 'd', 'l', 'e', 'w', 'a', 'r', 'e', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '"', ':')
		b = json.AppendString(b, v.MiddlewareVersion.Value)
		b = append(b, ","...)
	}
	b = append(b, `"node_version":`...)
	b = json.AppendString(b, v.NodeVersion)
	b = append(b, ',', '"', 'r', 'o', 's', 'e', 't', 't', 'a', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '"', ':')
	b = json.AppendString(b, v.RosettaVersion)
	return append(b, "}"...)
}

// Equal returns whether two Version values are equal.
func (v Version) Equal(o Version) bool {
	return string(v.Metadata) == string(o.Metadata) &&
		v.MiddlewareVersion.Value == o.MiddlewareVersion.Value &&
		v.MiddlewareVersion.Set == o.MiddlewareVersion.Set &&
		v.NodeVersion == o.NodeVersion &&
		v.RosettaVersion == o.RosettaVersion
}

// Reset resets Version so that it can be reused.
func (v *Version) Reset() {
	v.Metadata = v.Metadata[:0]
	v.MiddlewareVersion.Value = ""
	v.MiddlewareVersion.Set = false
	v.NodeVersion = ""
	v.RosettaVersion = ""
}

func accountIdentifierSliceEqual(a, b []AccountIdentifier) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func amountSliceEqual(a, b []Amount) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func balanceExemptionSliceEqual(a, b []BalanceExemption) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func blockEventSliceEqual(a, b []BlockEvent) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func blockTransactionSliceEqual(a, b []BlockTransaction) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func coinSliceEqual(a, b []Coin) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func currencySliceEqual(a, b []Currency) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func errorSliceEqual(a, b []Error) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func networkIdentifierSliceEqual(a, b []NetworkIdentifier) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func operationSliceEqual(a, b []Operation) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func operationIdentifierSliceEqual(a, b []OperationIdentifier) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func operationStatusSliceEqual(a, b []OperationStatus) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func peerSliceEqual(a, b []Peer) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func publicKeySliceEqual(a, b []PublicKey) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func relatedTransactionSliceEqual(a, b []RelatedTransaction) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func signatureSliceEqual(a, b []Signature) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func signingPayloadSliceEqual(a, b []SigningPayload) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func transactionSliceEqual(a, b []Transaction) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}

func transactionIdentifierSliceEqual(a, b []TransactionIdentifier) bool {
	for i, elem := range a {
		if !elem.Equal(b[i]) {
			return false
		}
	}
	return true
}
